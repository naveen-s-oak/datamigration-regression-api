<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.2.1">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments">1. Create your project folder
2. Create two folders at the same level under your project folder. Names must be &quot;apisToBeValidatedPath&quot; and &quot;apiInputsPath&quot;
3. All your test scenarios should be created as a CSV file, and expected response should also be in the same file. One line of the CSV should contain
all the inputs fields for the JSON and the expected values in the results json. Both of these should be separated by a field called &quot;expectedResponseCode&quot;.
4. In the &quot;User Defined Variables - Main&quot;, enter the right value for &quot;projectFolderPath&quot; and &quot;pathSeparator&quot; (based on your underlying OS).
5. Copy the &quot;CSVTOJSON&quot; conversion utility to the load injection machine and specify its appropriate path under 
&quot;User Defined Variables - Main&quot;-&gt;&quot;csvJSONConversionUtility&quot; variable.</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables-Properties" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="debug" elementType="Argument">
            <stringProp name="Argument.name">debug</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="projectFolderPath" elementType="Argument">
            <stringProp name="Argument.name">projectFolderPath</stringProp>
            <stringProp name="Argument.value">C:\Automation\Data migration - Mambu to Abacus</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="pathSeparator" elementType="Argument">
            <stringProp name="Argument.name">pathSeparator</stringProp>
            <stringProp name="Argument.value">\\</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="chromeDriverPath" elementType="Argument">
            <stringProp name="Argument.name">chromeDriverPath</stringProp>
            <stringProp name="Argument.value">C:\\ACorn\\chromedriver.exe</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="csvJSONConversionUtility" elementType="Argument">
            <stringProp name="Argument.name">csvJSONConversionUtility</stringProp>
            <stringProp name="Argument.value">file:///C:/ACORN/convertCSV/csv-to-json.htm</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="server" elementType="Argument">
            <stringProp name="Argument.name">server</stringProp>
            <stringProp name="Argument.value">cbdevint.acornmachine-it.com</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="port" elementType="Argument">
            <stringProp name="Argument.name">port</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="protocol" elementType="Argument">
            <stringProp name="Argument.name">protocol</stringProp>
            <stringProp name="Argument.value">http</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="apiHeaders" elementType="Argument">
            <stringProp name="Argument.name">apiHeaders</stringProp>
            <stringProp name="Argument.value">{&quot;Content-Type&quot;:&quot;application/json&quot;,&quot;x-tenant-identifier&quot;:&quot;testground&quot;}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="apiHeadersGETPUT" elementType="Argument">
            <stringProp name="Argument.name">apiHeadersGETPUT</stringProp>
            <stringProp name="Argument.value">{&quot;Content-Type&quot;:&quot;application/json&quot;,&quot;Accept&quot;:&quot;application/json&quot;,&quot;x-tenant-identifier&quot;:&quot;testground&quot;,&quot;User&quot;:&quot;operator&quot;,&quot;uuid&quot;:sgdsfdgs}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
        <stringProp name="TestPlan.comments">C:\\ACorn</stringProp>
      </Arguments>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables - Derived" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="apisToBeValidatedPath" elementType="Argument">
            <stringProp name="Argument.name">apisToBeValidatedPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}apisToBeValidated${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="apiInputsPath" elementType="Argument">
            <stringProp name="Argument.name">apiInputsPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}apiInputs${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="jsonWorkbenchPath" elementType="Argument">
            <stringProp name="Argument.name">jsonWorkbenchPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}jsonWorkbench${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="jsonWorkbenchResultsValidationPath" elementType="Argument">
            <stringProp name="Argument.name">jsonWorkbenchResultsValidationPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}jsonWorkbench${pathSeparator}expectedResults${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="jsonPayloadPath" elementType="Argument">
            <stringProp name="Argument.name">jsonPayloadPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}jsonPayload${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="jsonOutputPath" elementType="Argument">
            <stringProp name="Argument.name">jsonOutputPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}jsonOutput${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="resultsPath" elementType="Argument">
            <stringProp name="Argument.name">resultsPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}results${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="pathSeparator" elementType="Argument">
            <stringProp name="Argument.name">pathSeparator</stringProp>
            <stringProp name="Argument.value">${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="apiHeaders" elementType="Argument">
            <stringProp name="Argument.name">apiHeaders</stringProp>
            <stringProp name="Argument.value">${apiHeaders}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="overallDebug" elementType="Argument">
            <stringProp name="Argument.name">overallDebug</stringProp>
            <stringProp name="Argument.value">${debug}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="errorsPath" elementType="Argument">
            <stringProp name="Argument.name">errorsPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}errors${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="jsonWorkbenchURLParametersPath" elementType="Argument">
            <stringProp name="Argument.name">jsonWorkbenchURLParametersPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}jsonWorkbench${pathSeparator}urlParameters${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="urlInputField" elementType="Argument">
            <stringProp name="Argument.name">urlInputField</stringProp>
            <stringProp name="Argument.value">2</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="apiHeadersGETPUT" elementType="Argument">
            <stringProp name="Argument.name">apiHeadersGETPUT</stringProp>
            <stringProp name="Argument.value">${apiHeadersGETPUT}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="apiTestResult" elementType="Argument">
            <stringProp name="Argument.name">apiTestResult</stringProp>
            <stringProp name="Argument.value">pass</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="fileCheck" elementType="Argument">
            <stringProp name="Argument.name">fileCheck</stringProp>
            <stringProp name="Argument.value">NA</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="jsonFileCheck" elementType="Argument">
            <stringProp name="Argument.name">jsonFileCheck</stringProp>
            <stringProp name="Argument.value">NA</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="expectedJsonPath" elementType="Argument">
            <stringProp name="Argument.name">expectedJsonPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}fileFromJson${pathSeparator}expectedJSON${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="payloadJsonPath" elementType="Argument">
            <stringProp name="Argument.name">payloadJsonPath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}fileFromJson${pathSeparator}payloadJSON${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="logFilePath" elementType="Argument">
            <stringProp name="Argument.name">logFilePath</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}fileLog${pathSeparator}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="fileFromJSON" elementType="Argument">
            <stringProp name="Argument.name">fileFromJSON</stringProp>
            <stringProp name="Argument.value">${projectFolderPath}${pathSeparator}fileFromJson${pathSeparator}selectedFieldsJSONAPI.json</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="false">
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="checkQuery"></stringProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="dataSource">linearExpansion</stringProp>
        <stringProp name="dbUrl">jdbc:mysql://mysql-dev.oaknorth.ai:3306</stringProp>
        <stringProp name="driver">com.mysql.jdbc.Driver</stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="password">tester2019</stringProp>
        <stringProp name="poolMax">10</stringProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <stringProp name="username">tester</stringProp>
        <boolProp name="preinit">false</boolProp>
        <stringProp name="initQuery"></stringProp>
        <stringProp name="connectionProperties"></stringProp>
      </JDBCDataSource>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="true">
        <stringProp name="dataSource">linearExpansion</stringProp>
        <stringProp name="poolMax">10</stringProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <boolProp name="preinit">false</boolProp>
        <stringProp name="initQuery"></stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="checkQuery"></stringProp>
        <stringProp name="dbUrl">jdbc:mysql://172.10.1.233:3306</stringProp>
        <stringProp name="driver">com.mysql.jdbc.Driver</stringProp>
        <stringProp name="username">migtestdb</stringProp>
        <stringProp name="password">mysql</stringProp>
        <stringProp name="connectionProperties"></stringProp>
      </JDBCDataSource>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename">${projectFolderPath}\Result.jtl</stringProp>
        <stringProp name="TestPlan.comments">${projectFolderPath}\Result.jtl</stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
        <boolProp name="displayJMeterProperties">false</boolProp>
        <boolProp name="displayJMeterVariables">true</boolProp>
        <boolProp name="displaySamplerProperties">true</boolProp>
        <boolProp name="displaySystemProperties">false</boolProp>
      </DebugPostProcessor>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="API Validation Thread Group_A" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration">32400</stringProp>
        <stringProp name="ThreadGroup.delay">1200</stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Set-up results file and directories before starting the test" enabled="true">
          <boolProp name="WAITING">true</boolProp>
          <boolProp name="SUCCESFULL">true</boolProp>
          <stringProp name="RESPONSE_CODE">200</stringProp>
          <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
          <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
          <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
          <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
          <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
          <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
          <stringProp name="URL"></stringProp>
          <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
        </kg.apc.jmeter.samplers.DummySampler>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create a timestamped folder name" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Create a timestamped folder
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create a timestamped folder name - Beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String testStartDate = dateFormatter.format(cal.getTime());
	String testStartTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;timeStampedFolderName&quot;,testStartDate.concat(&quot;_&quot;).concat(testStartTime));
	if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
	   // includes: Windows 2000,  Windows 95, Windows 98, Windows NT, Windows Vista, Windows XP
	   vars.put(&quot;operatingSystem&quot;,&quot;Windows&quot;);
	} else {
	   // everything else
	   vars.put(&quot;operatingSystem&quot;,&quot;Unix&quot;);
	}
	if (debug) log.info(&quot;Create a timestamped folder name - Beanshell ends&quot;);
} catch (Exception e) {
	System.out.println(&quot;Something terribly wrong with this test set-up? &quot;+ e.toString());
}
</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create all project directories as required" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Create all project directories
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create all project directories as required - beanshell starts&quot;);
	
	File errorsDirectory = new File(vars.get(&quot;errorsPath&quot;));
	if(!errorsDirectory.exists()){
	     errorsDirectory.mkdir();
	}
	
	String timeStampedErrorsPath = vars.get(&quot;errorsPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedErrorsDirectory = new File(timeStampedErrorsPath);
	if(!timeStampedErrorsDirectory.exists()){
	     timeStampedErrorsDirectory.mkdir();
	}
	vars.put(&quot;timeStampedErorsPath&quot;,timeStampedErrorsPath);
	if (debug) log.info(&quot;Create all project directories as required - beanshell ends&quot;);
	String errorsFileName = timeStampedErrorsPath.concat(&quot;errors_&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;).concat(&quot;.txt&quot;));
	vars.put(&quot;errorsFileName&quot;,errorsFileName);
	f = new FileOutputStream(errorsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error File Created&quot;);
	f.close();
	File jsonWorkbenchDirectory = new File(vars.get(&quot;jsonWorkbenchPath&quot;));
	if(!jsonWorkbenchDirectory.exists()){
	     jsonWorkbenchDirectory.mkdir();
	}
	String timeStampedJSONWorkbenchPath = vars.get(&quot;jsonWorkbenchPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJSONWorkbenchDirectory = new File(timeStampedJSONWorkbenchPath);
	if(!timeStampedJSONWorkbenchDirectory.exists()){
	     timeStampedJSONWorkbenchDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJSONWorkbenchPath&quot;,timeStampedJSONWorkbenchPath);
	File jsonWorkbenchResultsValidationDirectory = new File(vars.get(&quot;jsonWorkbenchResultsValidationPath&quot;));
	if(!jsonWorkbenchResultsValidationDirectory.exists()){
	     jsonWorkbenchResultsValidationDirectory.mkdir();
	}
	String timeStampedJSONWorkbenchResultsValidationPath = vars.get(&quot;jsonWorkbenchResultsValidationPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJsonWorkbenchResultsValidationDirectory = new File(timeStampedJSONWorkbenchResultsValidationPath);
	if(!timeStampedJsonWorkbenchResultsValidationDirectory.exists()){
	     timeStampedJsonWorkbenchResultsValidationDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;,timeStampedJSONWorkbenchResultsValidationPath);
	
	File jsonPayloadDirectory = new File(vars.get(&quot;jsonPayloadPath&quot;));
	if(!jsonPayloadDirectory.exists()){
	     jsonPayloadDirectory.mkdir();
	}
	
	String timeStampedJsonPayloadPath = vars.get(&quot;jsonPayloadPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJsonPayloadDirectory = new File(timeStampedJsonPayloadPath);
	if(!timeStampedJsonPayloadDirectory.exists()){
	     timeStampedJsonPayloadDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJsonPayloadPath&quot;,timeStampedJsonPayloadPath);
	
	File resultsDirectory = new File(vars.get(&quot;resultsPath&quot;));
	if(!resultsDirectory.exists()){
	     resultsDirectory.mkdir();
	}
	
	String timeStampledResultsPath = vars.get(&quot;resultsPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampledResultsDirectory = new File(timeStampledResultsPath);
	if(!timeStampledResultsDirectory.exists()){
	     timeStampledResultsDirectory.mkdir();
	}
	vars.put(&quot;timeStampledResultsPath&quot;,timeStampledResultsPath);
	JMeterUtils.setProperty(&quot;timeStampledResultsPath&quot;,timeStampledResultsPath);
	
	File jsonOutputDirectory = new File(vars.get(&quot;jsonOutputPath&quot;));
	if(!jsonOutputDirectory.exists()){
	     jsonOutputDirectory.mkdir();
	}
	
	String timeStampedJsonOutputPath = vars.get(&quot;jsonOutputPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJsonOutputDirectory = new File(timeStampedJsonOutputPath);
	if(!timeStampedJsonOutputDirectory.exists()){
	     timeStampedJsonOutputDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJsonOutputPath&quot;,timeStampedJsonOutputPath);
	
	//jsonWorkbenchURLParametersPath
	File jsonWorkbenchURLParametersDirectory = new File(vars.get(&quot;jsonWorkbenchURLParametersPath&quot;));
	if(!jsonWorkbenchURLParametersDirectory.exists()){
	     jsonWorkbenchURLParametersDirectory.mkdir();
	}

	String timeStampedJsonWorkbenchURLParametersPath = vars.get(&quot;jsonWorkbenchURLParametersPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedjJsonWorkbenchURLParametersDirectory = new File(timeStampedJsonWorkbenchURLParametersPath);
	if(!timeStampedjJsonWorkbenchURLParametersDirectory.exists()){
	     timeStampedjJsonWorkbenchURLParametersDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJsonWorkbenchURLParametersPath&quot;,timeStampedJsonWorkbenchURLParametersPath);
	

	
} catch (Exception e) {
	String errorCode = &quot;1100&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
} </stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create a file to Store the overall results" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Create a file to Store the API validation results
//Modified in N12 version
import org.apache.jmeter.util.JMeterUtils;

try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create a file to Store the Overall API validation results - beanshell starts&quot;);
	
	String apiResultsFileName = vars.get(&quot;timeStampledResultsPath&quot;).concat(&quot;overall_results.csv&quot;);
	f = new FileOutputStream(apiResultsFileName,false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	//print(&quot;Test Execution Date,Execution Time,API Name,API Payload Input file,Test Result&quot;);
	print(&quot;#,Payload Injection Date,Payload Injection Time,API Name,Module Name,Total TCs,Pass Count,Fail Count,Owner&quot;);
	f.close();
	vars.put(&quot;overallResultsFileName&quot;,apiResultsFileName);
	JMeterUtils.setProperty(&quot;overallResultsFileName&quot;,apiResultsFileName);
	if (debug) log.info(&quot;Create a file to Store the Overall API validation results - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1401&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
}</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="selectedFieldsJson File" enabled="true">
          <boolProp name="WAITING">true</boolProp>
          <boolProp name="SUCCESFULL">true</boolProp>
          <stringProp name="RESPONSE_CODE">200</stringProp>
          <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
          <stringProp name="REQUEST_DATA"></stringProp>
          <stringProp name="RESPONSE_DATA">${__FileToString(${fileFromJSON},,)}</stringProp>
          <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
          <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
          <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
          <stringProp name="URL"></stringProp>
          <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
        </kg.apc.jmeter.samplers.DummySampler>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Read Selected Fields Json File
import org.json.JSONArray;
import org.json.JSONObject;

String selectedFieldsJson = prev.getResponseDataAsString(); 
JSONArray selectedFieldsJsonArray = new JSONArray(selectedFieldsJson);
//log.info(String.valueOf(selectedFieldsJsonArray));
vars.put(&quot;selectedFieldsJsonArray&quot;,String.valueOf(selectedFieldsJsonArray));


</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="While there are APIs to be validated" enabled="true">
          <stringProp name="TestPlan.comments">		</stringProp>
          <stringProp name="WhileController.condition">true</stringProp>
        </WhileController>
        <hashTree>
          <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="Counter" enabled="true">
            <stringProp name="CounterConfig.start">1</stringProp>
            <stringProp name="CounterConfig.end"></stringProp>
            <stringProp name="CounterConfig.incr">1</stringProp>
            <stringProp name="CounterConfig.name">counterValue</stringProp>
            <stringProp name="CounterConfig.format"></stringProp>
            <boolProp name="CounterConfig.per_user">false</boolProp>
          </CounterConfig>
          <hashTree/>
          <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="true">
            <stringProp name="filename">${apisToBeValidatedPath}APIsToBeValidated.csv</stringProp>
            <stringProp name="fileEncoding"></stringProp>
            <stringProp name="variableNames">slNo,apiName,apiMethod,apiPath,apiInputsFile,toBeValidated,moduleName,fileType,payloadJSON,expectedJSON,consentPerson,scenario,mysql</stringProp>
            <boolProp name="ignoreFirstLine">true</boolProp>
            <stringProp name="delimiter">,</stringProp>
            <boolProp name="quotedData">false</boolProp>
            <boolProp name="recycle">false</boolProp>
            <boolProp name="stopThread">true</boolProp>
            <stringProp name="shareMode">shareMode.all</stringProp>
          </CSVDataSet>
          <hashTree/>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="Should this API Be Validated" enabled="true">
            <stringProp name="IfController.condition">&quot;${toBeValidated}&quot;==&quot;y&quot;</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
          </IfController>
          <hashTree>
            <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Check input file is available?" enabled="true">
              <boolProp name="WAITING">true</boolProp>
              <boolProp name="SUCCESFULL">true</boolProp>
              <stringProp name="RESPONSE_CODE">200</stringProp>
              <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
              <stringProp name="REQUEST_DATA">${apiInputsPath}${apiInputsFile}</stringProp>
              <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
              <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
              <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
              <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
              <stringProp name="URL"></stringProp>
              <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
            </kg.apc.jmeter.samplers.DummySampler>
            <hashTree>
              <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String filePath=vars.get(&quot;apiInputsPath&quot;);
String fileName = vars.get(&quot;apiInputsFile&quot;);
String apiName = vars.get(&quot;apiName&quot;);
String filePathString=filePath.concat(fileName);
File f = new File(filePathString);
if(f.exists() &amp;&amp; !f.isDirectory()) { 
   vars.put(&quot;fileCheck&quot;,&quot;y&quot;);
}
else
{
log.info(filePathString+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
 vars.put(&quot;fileCheck&quot;,&quot;n&quot;);
 System.out.println(filePathString+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
}
</stringProp>
              </BeanShellPreProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
              <stringProp name="IfController.condition">&quot;${fileCheck}&quot;==&quot;y&quot;</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
            </IfController>
            <hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Calculate number of fields in CSV for input and expected results" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="REVISE - Calculate number of fields in CSV for input and expected results" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//Calculate the number of fields in CSV for input
//try {
	Boolean debug;

	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Calculate number of fields in CSV for input and expected results - beanshell starts&quot;);
	String strCurrentLine;
	String overallInputFile = vars.get(&quot;apiInputsPath&quot;).concat(vars.get(&quot;apiInputsFile&quot;));
	if (debug) log.info(&quot;Overall Input File: &quot;+overallInputFile);
	vars.put(&quot;overallInputFile&quot;,overallInputFile);
	BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	StringBuilder sbInputScenarios;
	StringBuilder sbExpectedResults;
	String[] splitLine;
	if ((strCurrentLine = br.readLine()) != null) {
		splitLine = strCurrentLine.split(&quot;,&quot;);
	}
	//log.info(&quot;Split line length: &quot;+String.valueOf(splitLine.length));
	//start Field for input Payload
	//end Field for input JSON
	//startField for expected results JSON
	//end field for expected results JSON
	int startFieldForExpectedResults = 0;
	int urlInputField = Integer.parseInt(vars.get(&quot;urlInputField&quot;));
	Boolean expectedResponseCodeFound= false;
	String inputPayloadExistence = &quot;yes&quot;;
	for (int i=0;i&lt;splitLine.length;i++) {
		log.info(String.valueOf(i)+&quot;:&quot;+splitLine[i]);
		if (splitLine[i].equals(&quot;expectedResponseCode&quot;)) {
			break;
		} else {
			startFieldForExpectedResults++;
		}
	}
	
	if (debug) log.info(&quot;URLInput Starting and ending field: &quot;+vars.get(&quot;urlInputField&quot;));
	if (debug) log.info(&quot;Expected Results Starting Field: &quot;+String.valueOf(startFieldForExpectedResults));
	if ((startFieldForExpectedResults-urlInputField)==1) inputPayloadExistence = &quot;no&quot;;
	vars.put(&quot;startFieldForExpectedResults&quot;,String.valueOf(startFieldForExpectedResults));
	vars.put(&quot;totalNumberOfFields&quot;,String.valueOf(splitLine.length));
	vars.put(&quot;inputPayloadExistence&quot;,inputPayloadExistence);
	long millis = System.currentTimeMillis();
	vars.put(&quot;millis&quot;,String.valueOf(millis));

	
	/*
	int numberOfFields =0;
	int urlInputField = Integer.parseInt(vars.get(&quot;urlInputField&quot;));

	for (int i=0;i&lt;splitLine.length;i++) {
		log.info(splitLine[i]);
	}
	vars.put(&quot;inputFileStartingField&quot;,String.valueOf(urlInputField+1));
	for (int i=(urlInputField+1);i&lt;splitLine.length;i++) {
		if (splitLine[i].equals(&quot;expectedResponseCode&quot;)) {
			break;
			log.info(&quot;found expResCod&quot;);
		} else {
			numberOfFields++;
			log.info(&quot;incrementing no of fields&quot;);
		}
	}
	if (debug) log.info(&quot;Number of Fields: &quot;+String.valueOf(numberOfFields+urlInputField+1));
	vars.put(&quot;numberOfFields&quot;,String.valueOf(numberOfFields+urlInputField+1));
	vars.put(&quot;startCountForExpectedResults&quot;,String.valueOf(numberOfFields+urlInputField+2));
	vars.put(&quot;endCountForExpectedResults&quot;,String.valueOf(splitLine.length));
	//Current time in millis
	long millis = System.currentTimeMillis();
	vars.put(&quot;millis&quot;,String.valueOf(millis));
	if (debug) log.info(&quot;Calculate number of fields in CSV for input and expected results - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1200&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
	
}*/</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Split files and create exclusive files for URL Parameters, input fields &amp; expected results" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="REVISE - Split input file and store file names" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//Store input fields and expected results file names with full path
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Split input file and store file names - beanshell starts&quot;);
	String inputFile =null;
	inputFile=vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;inputFields&quot;).concat(vars.get(&quot;millis&quot;)).concat(vars.get(&quot;counterValue&quot;)).concat(&quot;.csv&quot;);
	if (debug) log.info(&quot;input file: &quot;+inputFile);	
	String expectedResultsFile =null;	
	expectedResultsFile= vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;expectedResults&quot;).concat(vars.get(&quot;millis&quot;)).concat(vars.get(&quot;counterValue&quot;)).concat(&quot;.csv&quot;);
	String urlInputFieldFile =null;
	urlInputFieldFile=vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;urlInputField&quot;).concat(vars.get(&quot;millis&quot;)).concat(vars.get(&quot;counterValue&quot;)).concat(&quot;.csv&quot;);
	if (debug) log.info(&quot;Expected results file: &quot;+expectedResultsFile);
	vars.put(&quot;inputFile&quot;,inputFile);
	vars.put(&quot;expectedResultsFile&quot;,expectedResultsFile);
	vars.put(&quot;urlInputFieldFile&quot;,urlInputFieldFile);
//vars.put(&quot;startFieldForExpectedResults&quot;,String.valueOf(startFieldForExpectedResults));
//	vars.put(&quot;totalNumberOfFields&quot;,String.valueOf(splitLine.length));
//	vars.put(&quot;inputPayloadExistence&quot;,inputPayloadExistence);
	int urlInputField = Integer.parseInt(vars.get(&quot;urlInputField&quot;));
	int totalNumberOfFields = Integer.parseInt(vars.get(&quot;totalNumberOfFields&quot;));
	log.info(&quot;totalNumberOfFields&quot;+vars.get(&quot;totalNumberOfFields&quot;));
	String inputPayloadExistence = vars.get(&quot;inputPayloadExistence&quot;);
	int startFieldForExpectedResults = Integer.parseInt(vars.get(&quot;startFieldForExpectedResults&quot;));
	
	String strCurrentLine;
	String overallInputFile = vars.get(&quot;apiInputsPath&quot;).concat(vars.get(&quot;apiInputsFile&quot;));
	if (debug) log.info(&quot;Overall Inputs File: &quot;+overallInputFile);
	
	//Perform Split - create URLInputField File
	BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	String line;
	String[] inputSplitLine;
	f = new FileOutputStream(urlInputFieldFile, false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	String csvLine=&quot;&quot;;
	while ((line=br.readLine())!=null) {
		inputSplitLine = line.split(&quot;,&quot;);
		csvLine = inputSplitLine[urlInputField];
		print(csvLine);
	}
	f.close();
	br.close();
log.info(&quot;13001&quot;);

	//Perform Split - Create input File
	
	if (inputPayloadExistence.equals(&quot;yes&quot;)) {
		BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
		String line;
		String[] inputSplitLine;
		f = new FileOutputStream(inputFile, false);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		while ((line=br.readLine())!=null) {
			inputSplitLine = line.split(&quot;,&quot;);
			String csvLine=&quot;&quot;;
			for (int i=(urlInputField+1);i&lt;=(startFieldForExpectedResults-1);i++) {
				if (i==(startFieldForExpectedResults-1)) {
					csvLine = csvLine.concat(inputSplitLine[i]);
				} else {
					csvLine = csvLine.concat(inputSplitLine[i]).concat(&quot;,&quot;);
				}
			}
			print(csvLine);
		}
	}
	f.close();
	br.close();
	log.info(&quot;13002&quot;);

	//Perform Split - Create expected results File
	BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	String line;
	String[] expectedResultSplitLine;
	f = new FileOutputStream(expectedResultsFile, false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	while ((line=br.readLine())!=null) {
		expectedResultSplitLine = line.split(&quot;,&quot;);
		String csvLine=&quot;&quot;;
		for (int i=startFieldForExpectedResults;i &lt; totalNumberOfFields;i++) {
			if (i==(expectedResultSplitLine.length-1)) {
				csvLine = csvLine.concat(expectedResultSplitLine[i]);
			} else {
				csvLine = csvLine.concat(expectedResultSplitLine[i]).concat(&quot;,&quot;);
			}
		}
		if (csvLine.length()&gt;0) {
			print(csvLine);
		}
	}
	f.close();
	br.close();
log.info(&quot;13003&quot;);
	
	//Find the number of columns
	/*BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	StringBuilder sbInputScenarios;
	StringBuilder sbExpectedResults;
	String[] splitLine;
	if ((strCurrentLine = br.readLine()) != null) {
		splitLine = strCurrentLine.split(&quot;,&quot;);
	}

	int inputFileStartingField = Integer.parseInt(vars.get(&quot;inputFileStartingField&quot;))-1;
	for (int i=inputFileStartingField;i&lt;splitLine.length;i++) {
		if (splitLine[i].equals(&quot;expectedResponseCode&quot;)) {
			break;
		} else {
			numberOfFields++;
		}
	}
	br.close();
	numberOfFields = inputFileStartingField+numberOfFields;
	*/
	
	
	if (debug) log.info(&quot;Split input file and store file names - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1300&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create a file to Store the API validation results" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//Create a file to Store the API/SQL validation results
try {

	String validationType = vars.get(&quot;mysql&quot;);
	
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create a file to Store the API validation results - beanshell starts&quot;);
	
	String apiResultsFileName = vars.get(&quot;timeStampledResultsPath&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;_&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(&quot;_results.csv&quot;);
	f = new FileOutputStream(apiResultsFileName,false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	if(validationType.equalsIgnoreCase(&quot;y&quot;))
	{
	print(&quot;Test Execution Date,Execution Time,SQL Query Name,Module Name,Test Scenario Number,Mysql Query,Actual Table Result,Test Result,Expected Response Code,Actual Response Code,Query Inputs File,Query Type ,My SQL Query,Reason For Failure,Owner&quot;);
	}else
	{
	print(&quot;Test Execution Date,Execution Time,API Name,Module Name,Test Scenario Number,JSON Payload,Results JSON File Name,Test Result,Expected Response Code,Actual Response Code,API Inputs File,API Method,API Path &amp; Value,Reason For Failure,Owner&quot;);
	}
	f.close();
	vars.put(&quot;apiResultsFileName&quot;,apiResultsFileName);
	
	if (debug) log.info(&quot;Create a file to Store the API validation results - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1400&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
}</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Condition the input and expected results file before converting CSV to JSON" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Condition the input and expected results file before converting CSV to JSON" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//condition the input file

import java.io.File;
import java.io.IOException;
import java.lang.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Condition the input and expected results file before converting CSV to JSON - beanshell starts&quot;);
	String existingInputFileName = vars.get(&quot;inputFile&quot;);
	String existingExpectedResultsFileName = vars.get(&quot;expectedResultsFile&quot;);
	String newInputFileName = vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;tempInput.csv&quot;);
	String newExpectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;tempExpectedResults.csv&quot;);
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
		f1 = new FileOutputStream(newInputFileName, false);
		p1 = new PrintStream(f1); 
		this.interpreter.setOut(p1); 
		String line;
		Boolean lineChanged =false;
		BufferedReader brTest = new BufferedReader(new FileReader(existingInputFileName));
		while ((line = brTest.readLine()) != null) {
			if (!lineChanged) {
				print(line.replace(&quot;.&quot;, &quot;/&quot;));
				lineChanged = true;
			} else {
				print(line);
			}
		}
		brTest.close();
		f1.close();
	}
	f1 = new FileOutputStream(newExpectedResultsFileName, false);
	p1 = new PrintStream(f1); 
	this.interpreter.setOut(p1); 
	String line;
	Boolean lineChanged =false;
	BufferedReader brTest = new BufferedReader(new FileReader(existingExpectedResultsFileName));
	while ((line = brTest.readLine()) != null) {
		if (!lineChanged) {
			print(line.replace(&quot;.&quot;, &quot;/&quot;));
			lineChanged = true;
		} else {
			print(line);
		}
	}
	brTest.close();
	f1.close();
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) new File(existingInputFileName).delete();
	new File(existingExpectedResultsFileName).delete();
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) new File(newInputFileName).renameTo(new File(existingInputFileName));
	new File(newExpectedResultsFileName).renameTo(new File(existingExpectedResultsFileName));
	if (debug) log.info(&quot;Condition the input and expected results file before converting CSV to JSON - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1700&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
              </hashTree>
              <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler- URL Parameters" enabled="true">
                <stringProp name="BeanShellSampler.query">import org.json.JSONArray;
import org.json.JSONObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
// 
try {
//log.info(&quot;I am inside CSV to JSON Converter&quot;);
String headerLine;

BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;urlInputFieldFile&quot;)));
		if ((line = brTest.readLine()) != null) {
			headerLine = line;//.replace(&quot;/&quot;,&quot;.&quot;);
		}
brTest.close();


//log.info(&quot;Header Line...&quot;+headerLine);
String[] headerLineSplit = headerLine.split(&quot;,&quot;);
String regex=&quot;/\\d+/&quot;;
for (int i=0;i&lt;headerLineSplit.length;i++) {
	Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
	Matcher matcher = pattern.matcher(headerLineSplit[i]);
	if (matcher.find()) {
		//log.info(&quot;found&quot;);
		String stringToBeReplaced = matcher.group(0).substring(0,(matcher.group(0).length()-1));
		String replacementString = stringToBeReplaced.replace(&quot;/&quot;,&quot;[&quot;);
		replacementString= replacementString.concat(&quot;]&quot;);
		//log.info(&quot;stringToBeReplaced...&quot;+stringToBeReplaced);
		//log.info(&quot;replacementString...&quot;+replacementString);
		headerLineSplit[i]=headerLineSplit[i].replace(stringToBeReplaced,replacementString);
		//log.info(&quot;headerLineSplit[i] after replacement: &quot;+headerLineSplit[i]);
		//headerLineSplit[i]=headerLineSplit[i].replaceAll(&quot;
	}
	headerLineSplit[i]=headerLineSplit[i].replace(&quot;/&quot;,&quot;.&quot;);
	
}

JSONArray inputFieldsJSONArray = new JSONArray();
JSONObject testDataJSONObject;
int count=0;
BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;urlInputFieldFile&quot;)));
while (((line = brTest.readLine()) != null)) {
	if (count&gt;0) {
		String[] testDataSplit = line.split(&quot;,&quot;);
		testDataJSONObject = new JSONObject();
		//log.info(&quot;Header row length :&quot;+String.valueOf(headerLineSplit.length));
		//log.info(&quot;Test Data length :&quot;+String.valueOf(testDataSplit.length));
		for (int i=0;i&lt;headerLineSplit.length;i++) {
			//log.info(String.valueOf(i));
			//log.info(headerLineSplit[i]);
			//log.info(testDataSplit[i]);
			//log.info(headerLineSplit[i]);
			if (i&lt;testDataSplit.length){
				//log.info(&quot;data avl&quot;);
				if (testDataSplit[i].length()==0 || testDataSplit[i].equals(&quot;null&quot;))
					testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
				else {
					if (testDataSplit[i].equalsIgnoreCase(&quot;true&quot;) || testDataSplit[i].equalsIgnoreCase(&quot;false&quot;)) {
						Boolean convertedValue = Boolean.parseBoolean(testDataSplit[i]);
						testDataJSONObject.put(headerLineSplit[i],convertedValue);	
					} else {
						try {
							Integer convertedValue = Integer.parseInt(testDataSplit[i]);
							testDataJSONObject.put(headerLineSplit[i],convertedValue);	
						} catch (Exception e) {
							try {
								Double convertedValue = Double.parseDouble(testDataSplit[i]);
								testDataJSONObject.put(headerLineSplit[i],convertedValue);	
							} catch (Exception e) {
								testDataJSONObject.put(headerLineSplit[i],testDataSplit[i]);	
							}
						}
					}
					
				}
			}else{ 
				//log.info(&quot;data not avl&quot;);

				testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
			}
			//log.info(String.valueOf(i)+&quot; - &quot;+testDataJSONObject.toString());
		}
		//log.info(&quot;outside for&quot;);
		String nestedJSON = JsonUnflattener.unflatten(testDataJSONObject.toString());
		try{
		inputFieldsJSONArray.put(new JSONObject(nestedJSON));
		} catch(Exception e){
			log.info(e.toString());
		}
		//log.info(&quot;added to json array&quot;);
	}
	count++;
}
vars.put(&quot;urlInputFieldArray&quot;,inputFieldsJSONArray.toString());
int urlInputFieldArraysize =inputFieldsJSONArray.length();
log.info(&quot;Final url parameters array: &quot;+inputFieldsJSONArray.toString());
log.info(&quot;urlInputFieldArraysize : &quot;+String.valueOf(urlInputFieldArraysize));
vars.put(&quot;jsonLoop&quot;,String.valueOf(urlInputFieldArraysize));
} catch (Exception e) {
	String errorCode=&quot;1710&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}

/*
Boolean debug;
if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
if (debug) log.info(&quot;entering into Dynamic Post Data Processor&quot;);
JSONObject payloadObject = new JSONObject(vars.get(&quot;payload&quot;));
String flattenedJSON = JsonFlattener.flatten(payloadObject.toString());
if (debug) log.info(&quot;Flattened result...:&quot;+flattenedJSON);
nestedJSON = JsonUnflattener.unflatten(flattenedJSONPayload.toString());
*/


/*
try {
	var pkg = JavaImporter(org.openqa.selenium)
	var support_ui = JavaImporter(org.openqa.selenium.support.ui.WebDriverWait)
	var wait = new support_ui.WebDriverWait(WDS.browser, 10000)
	WDS.sampleResult.sampleStart()
	WDS.sampleResult.getLatency()
	WDS.browser.get(WDS.props.get(&quot;csvJSONConversionUtility&quot;))
	var fileUploadTab = WDS.browser.findElement(pkg.By.linkText(&quot;Choose File&quot;))
	fileUploadTab.click()
	var fileUploadButton = WDS.browser.findElement(pkg.By.id(&apos;f1&apos;))
	fileUploadButton.click()
	fileUploadButton.sendKeys(WDS.vars.get(&quot;inputFile&quot;))
	var screenshot1 = WDS.browser.getScreenshotAs(pkg.OutputType.FILE)
	screenshot1.renameTo(new java.io.File(&apos;screenshot1.png&apos;))
	screenshot1 = WDS.browser.getScreenshotAs(pkg.OutputType.FILE)
	screenshot1.renameTo(new java.io.File(&apos;screenshot1.png&apos;))
	var inputFileArray = WDS.browser.findElement(pkg.By.id(&apos;txta&apos;)).getAttribute(&apos;value&apos;)
	WDS.vars.put(&quot;inputFieldsJsonArray&quot;,inputFileArray)
	//WDS.log.info(inputFileArray)
	//WDS.browser.close();
} catch (err) {
   throw err
}*/</stringProp>
                <stringProp name="BeanShellSampler.filename"></stringProp>
                <stringProp name="BeanShellSampler.parameters"></stringProp>
                <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
              </BeanShellSampler>
              <hashTree/>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If input payload is applicable" enabled="true">
                <stringProp name="IfController.condition">&quot;${inputPayloadExistence}&quot;==&quot;yes&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler- Input Parameters" enabled="true">
                  <stringProp name="BeanShellSampler.query">//CSV TO JSON Converter
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
import java.util.regex.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;

// 

//log.info(&quot;I am inside CSV to JSON Converter&quot;);
String headerLine;

BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;inputFile&quot;)));
		if ((line = brTest.readLine()) != null) {
			headerLine = line;//.replace(&quot;/&quot;,&quot;.&quot;);
		}
brTest.close();


//log.info(&quot;Header Line...&quot;+headerLine);
String[] headerLineSplit = headerLine.split(&quot;,&quot;);
String regex=&quot;/\\d+/&quot;;
for (int i=0;i&lt;headerLineSplit.length;i++) {
	Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
	Matcher matcher = pattern.matcher(headerLineSplit[i]);
	if (matcher.find()) {
		//log.info(&quot;found&quot;);
		String stringToBeReplaced = matcher.group(0).substring(0,(matcher.group(0).length()-1));
		String replacementString = stringToBeReplaced.replace(&quot;/&quot;,&quot;[&quot;);
		replacementString= replacementString.concat(&quot;]&quot;);
		//log.info(&quot;stringToBeReplaced...&quot;+stringToBeReplaced);
		//log.info(&quot;replacementString...&quot;+replacementString);
		headerLineSplit[i]=headerLineSplit[i].replace(stringToBeReplaced,replacementString);
		//log.info(&quot;headerLineSplit[i] after replacement: &quot;+headerLineSplit[i]);
		//headerLineSplit[i]=headerLineSplit[i].replaceAll(&quot;
	}
	headerLineSplit[i]=headerLineSplit[i].replace(&quot;/&quot;,&quot;.&quot;);
	
}

JSONArray inputFieldsJSONArray = new JSONArray();
JSONObject testDataJSONObject;
int count=0;
BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;inputFile&quot;)));
while (((line = brTest.readLine()) != null)) {
	if (count&gt;0) {
		String[] testDataSplit = line.split(&quot;,&quot;);
		testDataJSONObject = new JSONObject();
		//log.info(&quot;Header row length :&quot;+String.valueOf(headerLineSplit.length));
		//log.info(&quot;Test Data length :&quot;+String.valueOf(testDataSplit.length));
		for (int i=0;i&lt;headerLineSplit.length;i++) {
			//log.info(String.valueOf(i));
			//log.info(headerLineSplit[i]);
			//log.info(testDataSplit[i]);
			//log.info(headerLineSplit[i]);
			if (i&lt;testDataSplit.length){
				if (!testDataSplit[i].equals(&quot;IGNORE&quot;)) {
				//log.info(&quot;data avl&quot;);
					if (testDataSplit[i].length()==0 || testDataSplit[i].equals(&quot;null&quot;))
						testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
					else {
						if (testDataSplit[i].equalsIgnoreCase(&quot;true&quot;) || testDataSplit[i].equalsIgnoreCase(&quot;false&quot;)) {
							Boolean convertedValue = Boolean.parseBoolean(testDataSplit[i]);
							testDataJSONObject.put(headerLineSplit[i],convertedValue);	
						} else {
							try {
								JSONArray convertedValue = new JSONArray(testDataSplit[i]);
								testDataJSONObject.put(headerLineSplit[i],convertedValue);	
							} catch (Exception e) {
								try {
									JSONObject convertedValue = new JSONObject(testDataSplit[i]);
									testDataJSONObject.put(headerLineSplit[i],convertedValue);
								} catch (Exception e) {
									try {
										Integer convertedValue = Integer.parseInt(testDataSplit[i]);
										testDataJSONObject.put(headerLineSplit[i],convertedValue);	
									} catch (Exception e) {
										try {
											Double convertedValue = Double.parseDouble(testDataSplit[i]);
											testDataJSONObject.put(headerLineSplit[i],convertedValue);	
										} catch (Exception e) {
											testDataJSONObject.put(headerLineSplit[i],testDataSplit[i]);	
										}
									}
								}
							}
						}	
					}
				}
			}else{ 
				//log.info(&quot;data not avl&quot;);

				testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
			}
			//log.info(String.valueOf(i)+&quot; - &quot;+testDataJSONObject.toString());
		}
		//log.info(&quot;outside for&quot;);
		String nestedJSON = JsonUnflattener.unflatten(testDataJSONObject.toString());
		try{
		inputFieldsJSONArray.put(new JSONObject(nestedJSON));
		} catch(Exception e){
			log.info(e.toString());
		}
		//log.info(&quot;added to json array&quot;);
	}
	count++;
}

//14-Oct-2019-Selva(Replace Null,NULL string to null value)

//log.info(&quot;Final input fields array: &quot;+inputFieldsJSONArray.toString());
//rplaceNULL------
String null_1=&quot;\&quot;NULL\&quot;&quot;;
String null_2=&quot;\&quot;Null\&quot;&quot;;
String  rplaceNULLinPayLoad= inputFieldsJSONArray.toString();
rplaceNULLinPayLoad = rplaceNULLinPayLoad.replace(null_1,&quot;\1null&quot;);
rplaceNULLinPayLoad = rplaceNULLinPayLoad.replace(null_2,&quot;\2null&quot;);
//vars.put(&quot;inputFieldsJsonArray&quot;,inputFieldsJSONArray.toString()); ---OLD

//16-Oct-2019-Selva (Date conversion mm/dd/yyyy to yyyy/mm/dd
//log.info(&quot;-------------&quot;+rplaceNULLinPayLoad);
String payloadDateConversion = rplaceNULLinPayLoad;

	  String regex = &quot;(\\d{1,2}/\\d{1,2}/\\d{4}|\\d{1,2}/\\d{1,2})&quot;;
	  // pattern_Match
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(payloadDateConversion);      
		HashSet  set=new HashSet(); 
        HashSet  set2=new HashSet(); 
        int count = 0;
        //log.info(&quot;----1&quot;);
         while (matcher.find()){
        String groupValue =matcher.group();
        boolean isDate = false;
          String datePattern = &quot;\\d{1,2}/\\d{1,2}/\\d{4}&quot;;      
          isDate = groupValue.matches(datePattern);
          //log.info(&quot;expectedResultsFile-Check this is Date...? &quot;+groupValue+&quot;---&gt;&quot;+String.valueOf(isDate));
          if(isDate)
          {
              count++;
              set.add(groupValue);
          }
         }
    ArrayList  listSort = new ArrayList(set);
    log.info(String.valueOf(listSort));
    log.info(&quot;Size--&gt;&quot;+String.valueOf(listSort.size()));
    for(int i=0;i&lt;listSort.size();i++)
     {
        //log.info(String.valueOf(listSort.get(i)));
        String[] a=listSort.get(i).split(&quot;/&quot;);
        int  v = Integer.valueOf(a[0]); 
        if(10&lt;=v)
        {
            String beforeDateConversion = String.valueOf(listSort.get(i));
             Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);            
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            log.info(beforeDateConversion+&quot;----&gt;&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);      
            }
    else
        {
          set2.add(listSort.get(i));
        }
   }         
         //log.info(&quot;Total date count is.....&quot;+String.valueOf(count));
         Iterator itr=set2.iterator();  
         while(itr.hasNext()){  
            //log.info(String.valueOf(itr.next())); 
            String beforeDateConversion = String.valueOf(itr.next());
            Boolean check =false;
            //log.info(&quot;beforeDateConversion :&quot;+beforeDateConversion);
            Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);           
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            //log.info(&quot;afterDateConversion :&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);
             }
 
	  	//vars.put(&quot;payloadDateConversion&quot;,payloadDateConversion);
	  	vars.put(&quot;inputFieldsJsonArray&quot;,payloadDateConversion);
         

</stringProp>
                  <stringProp name="BeanShellSampler.filename"></stringProp>
                  <stringProp name="BeanShellSampler.parameters"></stringProp>
                  <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                </BeanShellSampler>
                <hashTree/>
              </hashTree>
              <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler- Expected Results" enabled="true">
                <stringProp name="BeanShellSampler.query">import org.json.JSONArray;
import org.json.JSONObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
import java.util.regex.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;
// 
try {
//log.info(&quot;I am inside CSV to JSON Converter&quot;);
String headerLine;

BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;expectedResultsFile&quot;)));
		if ((line = brTest.readLine()) != null) {
			headerLine = line;//.replace(&quot;/&quot;,&quot;.&quot;);
		}
brTest.close();


//log.info(&quot;Header Line...&quot;+headerLine);
String[] headerLineSplit = headerLine.split(&quot;,&quot;);
String regex=&quot;/\\d+/&quot;;
for (int i=0;i&lt;headerLineSplit.length;i++) {
	Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
	Matcher matcher = pattern.matcher(headerLineSplit[i]);
	if (matcher.find()) {
		//log.info(&quot;found&quot;);
		String stringToBeReplaced = matcher.group(0).substring(0,(matcher.group(0).length()-1));
		//log.info(&quot;String to be replaced********&quot;+stringToBeReplaced);
		String replacementString = stringToBeReplaced.replace(&quot;/&quot;,&quot;[&quot;);
		//log.info(&quot;replacement string***********&quot;+replacementString);
		replacementString= replacementString.concat(&quot;]&quot;);
		//log.info(&quot;stringToBeReplaced...&quot;+stringToBeReplaced);
		//log.info(&quot;replacementString...&quot;+replacementString);
		headerLineSplit[i]=headerLineSplit[i].replace(stringToBeReplaced,replacementString);
		//log.info(&quot;headerLineSplit[i] after replacement: &quot;+headerLineSplit[i]);
		//headerLineSplit[i]=headerLineSplit[i].replaceAll(&quot;
	}
	headerLineSplit[i]=headerLineSplit[i].replace(&quot;/&quot;,&quot;.&quot;);
	
}

JSONArray inputFieldsJSONArray = new JSONArray();
JSONObject testDataJSONObject;
int count=0;
BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;expectedResultsFile&quot;)));
while (((line = brTest.readLine()) != null)) {
	if (count&gt;0) {
		String[] testDataSplit = line.split(&quot;,&quot;);
		testDataJSONObject = new JSONObject();
		//log.info(&quot;Header row length :&quot;+String.valueOf(headerLineSplit.length));
		//log.info(&quot;Test Data length :&quot;+String.valueOf(testDataSplit.length));
		for (int i=0;i&lt;headerLineSplit.length;i++) {
			//log.info(String.valueOf(i));
			//log.info(headerLineSplit[i]);
			//log.info(testDataSplit[i]);
			//log.info(headerLineSplit[i]);
			if (i&lt;testDataSplit.length){
				//log.info(&quot;testDataSplit[i]: &quot;+testDataSplit[i]);
				//if (testDataSplit[i].equals(&quot;IGNORE&quot;)) log.info(&quot;reached ignore case.....&quot;);
				//if (!testDataSplit[i].equals(&quot;IGNORE&quot;)) {
				//log.info(&quot;data avl&quot;);
					if (testDataSplit[i].length()==0 || testDataSplit[i].equals(&quot;null&quot;))
						testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
					else {
						if (testDataSplit[i].equalsIgnoreCase(&quot;true&quot;) || testDataSplit[i].equalsIgnoreCase(&quot;false&quot;)) {
							Boolean convertedValue = Boolean.parseBoolean(testDataSplit[i]);
							testDataJSONObject.put(headerLineSplit[i],convertedValue);	
						} else {
							try {
								Integer convertedValue = Integer.parseInt(testDataSplit[i]);
								testDataJSONObject.put(headerLineSplit[i],convertedValue);	
							} catch (Exception e) {
								try {
									Double convertedValue = Double.parseDouble(testDataSplit[i]);
									testDataJSONObject.put(headerLineSplit[i],convertedValue);	
								} catch (Exception e) {
									//log.info(&quot;Is this ignore? &quot;+testDataSplit[i]);
									if (!testDataSplit[i].equals(&quot;IGNORE&quot;)) testDataJSONObject.put(headerLineSplit[i],testDataSplit[i]);	
								}
							}
						}
						
					}
				//}
			}else{ 
				//log.info(&quot;data not avl&quot;);
				//log.info(&quot;test data is: &quot;+testDataSplit[i]);
				testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
			}
			//log.info(String.valueOf(i)+&quot; - &quot;+testDataJSONObject.toString());
		}
		//log.info(&quot;outside for&quot;);
		//log.info(&quot;Test Data JSON OBJ - &quot;+testDataJSONObject.toString());
		String nestedJSON = JsonUnflattener.unflatten(testDataJSONObject.toString());
		try{
			inputFieldsJSONArray.put(new JSONObject(nestedJSON));
		} catch(Exception e){
			log.info(e.toString());
		}
		//log.info(&quot;added to json array&quot;);
	}
	count++;
}
//log.info(&quot;Final expected results array: &quot;+inputFieldsJSONArray.toString());



String payloadDateConversion = inputFieldsJSONArray.toString();

log.info(&quot;payloadDateConversion----&gt;&quot;+payloadDateConversion);

	  String regex = &quot;(\\d{1,2}/\\d{1,2}/\\d{4}|\\d{1,2}/\\d{1,2})&quot;;
	  // pattern_Match
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(payloadDateConversion);      
		HashSet  set=new HashSet(); 
        HashSet  set2=new HashSet(); 
        int count = 0;
        //log.info(&quot;----1&quot;);
         while (matcher.find()){
        String groupValue =matcher.group();
        boolean isDate = false;
          String datePattern = &quot;\\d{1,2}/\\d{1,2}/\\d{4}&quot;;      
          isDate = groupValue.matches(datePattern);
          //log.info(&quot;expectedResultsFile-Check this is Date...? &quot;+groupValue+&quot;---&gt;&quot;+String.valueOf(isDate));
          if(isDate)
          {
              count++;
              set.add(groupValue);
          }
         }
    ArrayList  listSort = new ArrayList(set);
    log.info(String.valueOf(listSort));
    log.info(&quot;Size--&gt;&quot;+String.valueOf(listSort.size()));
    for(int i=0;i&lt;listSort.size();i++)
     {
        //log.info(String.valueOf(listSort.get(i)));
        String[] a=listSort.get(i).split(&quot;/&quot;);
        int  v = Integer.valueOf(a[0]); 
        if(10&lt;=v)
        {
            String beforeDateConversion = String.valueOf(listSort.get(i));
             Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);            
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            log.info(beforeDateConversion+&quot;----&gt;&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);      
            }
    else
        {
          set2.add(listSort.get(i));
        }
   }         
         //log.info(&quot;Total date count is.....&quot;+String.valueOf(count));
         Iterator itr=set2.iterator();  
         while(itr.hasNext()){  
            //log.info(String.valueOf(itr.next())); 
            String beforeDateConversion = String.valueOf(itr.next());
            Boolean check =false;
            //log.info(&quot;beforeDateConversion :&quot;+beforeDateConversion);
            Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);           
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            log.info(beforeDateConversion+&quot;----&gt;&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);
             }
	         
vars.put(&quot;expectedResultsArray&quot;,payloadDateConversion);
} catch(Exception e) {	
	String errorCode=&quot;18000&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}

</stringProp>
                <stringProp name="BeanShellSampler.filename"></stringProp>
                <stringProp name="BeanShellSampler.parameters"></stringProp>
                <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
              </BeanShellSampler>
              <hashTree/>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Store the input and expected files JSON post conversion" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Store the input and expected files JSON post conversion" enabled="true">
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="script">//Store input and expected files JSON post conversion
import org.json.JSONArray;
import org.json.JSONObject;
import java.lang.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the input and expected files JSON post conversion - beanshell starts&quot;);
	long millis = System.currentTimeMillis();
	String trackingFile = vars.get(&quot;jsonWorkbenchPath&quot;).concat(&quot;jsonPayloadTracker_&quot;).concat(String.valueOf(millis)).concat(&quot;.csv&quot;);
	vars.put(&quot;payloadTrackingFile&quot;,trackingFile);
	f3 = new FileOutputStream(trackingFile,false);
	f3.close();
	if(vars.get(&quot;fileType&quot;).equalsIgnoreCase(&quot;json&quot;))
	{
		vars.put(&quot;inputFieldsJsonArray&quot;,null);
	}
	JSONArray newInputFieldsArray = new JSONArray(vars.get(&quot;inputFieldsJsonArray&quot;));
	if (debug) log.info(&quot;InputFields JSON Array: &quot;+vars.get(&quot;inputFieldsJsonArray&quot;));
	JSONArray newExpectedResultsArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
	if (debug) log.info(&quot;Expected Results JSON Array: &quot;+vars.get(&quot;expectedResultsArray&quot;));	
	JSONArray newUrlInputFieldArray = new JSONArray(vars.get(&quot;urlInputFieldArray&quot;));
	if (debug) log.info(&quot;URL Parameter Fields JSON Array: &quot;+vars.get(&quot;urlInputFieldArray&quot;));	
//Log for each API 
String logFilePath =vars.get(&quot;logFilePath&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;.txt&quot;);
log.info(logFilePath);
f5 = new FileOutputStream(logFilePath,true);
		PrintStream p5 = new PrintStream(f5);
		this.interpreter.setOut(p5); 
		print(vars.get(&quot;apiName&quot;));
		print(&quot;inputFieldsJsonArray:&quot; + vars.get(&quot;inputFieldsJsonArray&quot;));
		print(&quot;expectedResultsArray: &quot;+vars.get(&quot;expectedResultsArray&quot;));
		print(&quot;urlInputFieldArray: &quot;+vars.get(&quot;urlInputFieldArray&quot;));
		f5.close();




		
	for (int i=0;i&lt;newUrlInputFieldArray.length();i++) {
		String jsonPayloadFileName =&quot;&quot;;
		if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
			jsonPayloadFileName = vars.get(&quot;timeStampedJsonPayloadPath&quot;).concat(&quot;testScenario_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		} 
		String expectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;).concat(&quot;expectedResults_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		String urlInputFieldFileName = vars.get(&quot;timeStampedJsonWorkbenchURLParametersPath&quot;).concat(&quot;urlInputFields_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		//create JSON Payload and expected results Tracking File
		f2 = new FileOutputStream(trackingFile,true);
		PrintStream p2 = new PrintStream(f2);
		this.interpreter.setOut(p2); 
		print((i+1)+&quot;,&quot;+jsonPayloadFileName+&quot;,&quot;+expectedResultsFileName+&quot;,&quot;+urlInputFieldFileName);
		f2.close();
		//Create JSON Payload file
		if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
			f = new FileOutputStream(jsonPayloadFileName, false);
			p = new PrintStream(f); 
			this.interpreter.setOut(p); 
			print(newInputFieldsArray.getJSONObject(i));
			f.close();
			System.out.println(&quot;18001&quot;);
		}
		//Create Expected Payload file
		f4 = new FileOutputStream(expectedResultsFileName, false);
		p4 = new PrintStream(f4); 
		this.interpreter.setOut(p4); 
		print(newExpectedResultsArray.getJSONObject(i));
		f4.close();	
		//Create URLInputField File	
		f5 = new FileOutputStream(urlInputFieldFileName, false);
		p5 = new PrintStream(f5); 
		this.interpreter.setOut(p5); 
		print(newUrlInputFieldArray.getJSONObject(i));
		f5.close();	
System.out.println(&quot;18002&quot;);
	}
	if (debug) log.info(&quot;Store the input and expected files JSON post conversion - beanshell ends&quot;);
} catch(Exception e) {
	String errorCode=&quot;1800&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}
</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Find the number of scenarios to be validated" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">String fileName = vars.get(&quot;payloadTrackingFile&quot;);
log.info(&quot;Filename: &quot;+fileName);
int numberOfRowsInCSV=0;

BufferedReader brTest = new BufferedReader(new FileReader(fileName));
		while ((line = brTest.readLine()) != null) {
			numberOfRowsInCSV++;
		}
brTest.close();
vars.put(&quot;numberOfRowsInCSV&quot;,String.valueOf(numberOfRowsInCSV));
</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${server}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">http</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="false">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                      <stringProp name="Header.value">wepemnefret</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">uuid</stringProp>
                      <stringProp name="Header.value">asdkasd</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                      <stringProp name="Header.value">testground</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                </JSONPostProcessor>
                <hashTree/>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - Record Thread Start Time" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//RecordStartTime
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller_CSV" enabled="true">
                <stringProp name="IfController.condition">&quot;${fileType}&quot;==&quot;csv&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
                  <boolProp name="LoopController.continue_forever">true</boolProp>
                  <stringProp name="LoopController.loops">${numberOfRowsInCSV}</stringProp>
                </LoopController>
                <hashTree>
                  <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read data from payload tracker" enabled="true">
                    <boolProp name="WAITING">true</boolProp>
                    <boolProp name="SUCCESFULL">true</boolProp>
                    <stringProp name="RESPONSE_CODE">200</stringProp>
                    <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                    <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                    <stringProp name="RESPONSE_DATA">${__CSVRead(${payloadTrackingFile},0)}|${__CSVRead(${payloadTrackingFile},1)}|${__CSVRead(${payloadTrackingFile},2)}|${__CSVRead(${payloadTrackingFile},3)}${__CSVRead(${payloadTrackingFile},next)}</stringProp>
                    <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                    <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                    <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                    <stringProp name="URL"></stringProp>
                    <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                  </kg.apc.jmeter.samplers.DummySampler>
                  <hashTree>
                    <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                      <boolProp name="resetInterpreter">false</boolProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">//testScenarioNumber,payloadFilePath,expectedResultsFilePath,urlInputFieldsFilePath
String responseMsg = prev.getResponseDataAsString();
log.info(responseMsg);
String[] responseMsgSplit = responseMsg.split(&quot;\\|&quot;);
vars.put(&quot;testScenarioNumber&quot;,responseMsgSplit[0]);
vars.put(&quot;payloadFilePath&quot;,responseMsgSplit[1]);
vars.put(&quot;expectedResultsFilePath&quot;,responseMsgSplit[2]);
vars.put(&quot;urlInputFieldsFilePath&quot;,responseMsgSplit[3]);
log.info(responseMsgSplit[0]);
log.info(responseMsgSplit[1]);
log.info(responseMsgSplit[2]);
log.info(responseMsgSplit[3]);</stringProp>
                    </BeanShellPostProcessor>
                    <hashTree/>
                  </hashTree>
                  <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                    <stringProp name="IfController.condition">&quot;${testScenarioNumber}&quot;!=&quot;&lt;EOF&gt;&quot;</stringProp>
                    <boolProp name="IfController.evaluateAll">false</boolProp>
                  </IfController>
                  <hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Expected Results into a variable" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__FileToString(${expectedResultsFilePath},,expectedResults)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree/>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If input payload is applicable" enabled="true">
                      <stringProp name="IfController.condition">&quot;${inputPayloadExistence}&quot;==&quot;yes&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read JSON Payload into a variable" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${payloadFilePath},,jsonPayload)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree/>
                    </hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read URL Parameter into a variable" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__FileToString(${urlInputFieldsFilePath},,urlInputParameters)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree/>
                    <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler - Check elapsed time" enabled="true">
                      <stringProp name="BeanShellSampler.query">//Check Elapsed Time
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
long startTime=Long.valueOf(vars.get(&quot;startTime_&quot;+ctx.getThreadNum()));
double diff = (timeMilli-startTime)/60000;

if (diff &gt;= 18.0) {
	vars.put(&quot;relogin&quot;,&quot;1&quot;);
} else {
	vars.put(&quot;relogin&quot;,&quot;0&quot;);
}
</stringProp>
                      <stringProp name="BeanShellSampler.filename"></stringProp>
                      <stringProp name="BeanShellSampler.parameters"></stringProp>
                      <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                    </BeanShellSampler>
                    <hashTree/>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If elapsed time" enabled="true">
                      <stringProp name="IfController.condition">&quot;${relogin}&quot;==&quot;1&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token " enabled="true">
                        <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                        <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                          <collectionProp name="Arguments.arguments">
                            <elementProp name="" elementType="HTTPArgument">
                              <boolProp name="HTTPArgument.always_encode">false</boolProp>
                              <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                              <stringProp name="Argument.metadata">=</stringProp>
                            </elementProp>
                          </collectionProp>
                        </elementProp>
                        <stringProp name="HTTPSampler.domain">${server}</stringProp>
                        <stringProp name="HTTPSampler.port"></stringProp>
                        <stringProp name="HTTPSampler.protocol">http</stringProp>
                        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                        <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                        <stringProp name="HTTPSampler.method">POST</stringProp>
                        <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                        <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                        <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                        <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                        <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                        <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                        <stringProp name="HTTPSampler.response_timeout"></stringProp>
                        <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                      </HTTPSamplerProxy>
                      <hashTree>
                        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                          <collectionProp name="HeaderManager.headers">
                            <elementProp name="" elementType="Header">
                              <stringProp name="Header.name">Content-Type</stringProp>
                              <stringProp name="Header.value">application/json</stringProp>
                            </elementProp>
                            <elementProp name="" elementType="Header">
                              <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                              <stringProp name="Header.value">testground</stringProp>
                            </elementProp>
                          </collectionProp>
                        </HeaderManager>
                        <hashTree/>
                        <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                          <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                          <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                          <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                          <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                        </JSONPostProcessor>
                        <hashTree/>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - timeCheck" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//RecordStartTime2
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
vars.put(&quot;relogin&quot;,&quot;0&quot;);</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                    </hashTree>
                    <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="API Name - ${apiName}" enabled="true">
                      <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                        <collectionProp name="Arguments.arguments"/>
                      </elementProp>
                      <stringProp name="HTTPSampler.domain">${server}</stringProp>
                      <stringProp name="HTTPSampler.port">${port}</stringProp>
                      <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
                      <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                      <stringProp name="HTTPSampler.path"></stringProp>
                      <stringProp name="HTTPSampler.method">POST</stringProp>
                      <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                      <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                      <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                      <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                      <stringProp name="HTTPSampler.connect_timeout">120000</stringProp>
                      <stringProp name="HTTPSampler.response_timeout"></stringProp>
                      <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                    </HTTPSamplerProxy>
                    <hashTree>
                      <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                        <collectionProp name="HeaderManager.headers"/>
                      </HeaderManager>
                      <hashTree/>
                      <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Manage HTTP  Headers and api method for the REST API" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">
//Add any additional headers as required
import org.apache.jmeter.protocol.http.control.Header;
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell starts&quot;);
	sampler.setMethod(vars.get(&quot;apiMethod&quot;)); 
	JSONObject urlInputFields = new JSONObject(vars.get(&quot;urlInputParameters&quot;));
	if (debug) log.info(&quot;URL Input fields: &quot;+urlInputFields.toString());
	Object aObj = urlInputFields.get(&quot;urlParameter&quot;);
	String urlParameterValue=null;
	String apiFullPathValue =&quot;NA&quot;;
	if(aObj instanceof Integer){
   if (debug) log.info(&quot;Integer : &quot;+String.valueOf(aObj));
     urlParameterValue=urlInputFields.getInt(&quot;urlParameter&quot;).toString();
}
else
{
	if (debug) log.info(&quot;String :&quot;+String.valueOf(aObj));
	urlParameterValue=urlInputFields.getString(&quot;urlParameter&quot;);
}
if (debug) log.info(&quot;---&quot;+urlParameterValue);
	if (urlParameterValue.length()&gt;0 &amp;&amp; !urlParameterValue.equals(null) &amp;&amp; !urlParameterValue.equals(&quot;NA&quot;))
	{
		if (debug)log.info(&quot;--------------path with parameter&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue));
		apiFullPathValue = vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue);
	} else {
		if (debug) log.info(&quot;--------------only path&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;));		
		apiFullPathValue = vars.get(&quot;apiPath&quot;);
	}
	vars.put(&quot;apiFullPathValue&quot;,apiFullPathValue);
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
		if (vars.get(&quot;jsonPayload&quot;).length()&gt;5) {
			sampler.setPostBodyRaw(true);
			sampler.addNonEncodedArgument(&quot;&quot;,vars.get(&quot;jsonPayload&quot;),&quot;&quot;);
		}
	}
	String apiHeadersString = &quot;&quot;;
	if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;)) apiHeadersString=vars.get(&quot;apiHeadersGETPUT&quot;); 
	else apiHeadersString=vars.get(&quot;apiHeaders&quot;);
	log.info(&quot;API Header String: &quot;+apiHeadersString);
	/*Collection c = sampler.getHeaderManager().getHeaders();
	for (Iterator i = c.iterator(); i.hasNext();) { 
       log.info(i.next());
	}*/
       
	int countOfExistingHeaders = sampler.getHeaderManager().size();
	if (debug) log.info(&quot;Count of headers: &quot;+String.valueOf(countOfExistingHeaders));
	if (countOfExistingHeaders==0) {
		//log.info(&quot;3&quot;);
		JSONObject apiHeadersObject = new JSONObject(apiHeadersString);
		//log.info(&quot;4&quot;);
		Iterator newKeys = apiHeadersObject.keys();
		while (newKeys.hasNext()) {
			String newKey = newKeys.next();
			sampler.getHeaderManager().add(new Header(newKey,apiHeadersObject.getString(newKey)));
		}
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	} else {
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	}


	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1900&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}
</stringProp>
                      </BeanShellPreProcessor>
                      <hashTree/>
                      <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Store the payload injection date and time" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//Store the payload injection date and time
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String payloadInjectionDate = dateFormatter.format(cal.getTime());
	String payloadInjectionTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;payloadInjectionDate&quot;,payloadInjectionDate);
	vars.put(&quot;payloadInjectionTime&quot;,payloadInjectionTime);
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2000&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode);
	f.close();
}</stringProp>
                      </BeanShellPreProcessor>
                      <hashTree/>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Store response JSON and validate response code" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//Store results JSON in the appropriate folder
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store response JSON and validate response code - beanshell starts&quot;);
	String jsonResultsFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;jsonOutput&quot;).concat(&quot;_&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;.json&quot;);
	vars.put(&quot;jsonResultsFileName&quot;,jsonResultsFileName);
	if (debug) log.info(jsonResultsFileName);
	f = new FileOutputStream(jsonResultsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(prev.getResponseDataAsString());
	f.close();
	//Create JSON Object for Actual Results
	JSONObject actualResult = new JSONObject();
	if (prev.getResponseDataAsString().toString().length()&gt;0) {
		actualResult = new JSONObject(prev.getResponseDataAsString());
	}
	//validate response Code
	String expectedResults = vars.get(&quot;expectedResults&quot;);
	JSONObject expectedResultsJSON = new JSONObject(expectedResults);
	int expectedResponseCode = expectedResultsJSON.get(&quot;expectedResponseCode&quot;);
	//JSONObject newExpectedResults after trimming the expected response code;
	if (String.valueOf(expectedResponseCode).equals(prev.getResponseCode())) {
		JSONObject newExpectedResult = new JSONObject();
		Iterator keys = expectedResultsJSON.keys();
		while(keys.hasNext()) {
		    String key = keys.next();
		    if (!key.equals(&quot;expectedResponseCode&quot;)) {
	    			newExpectedResult.put(key,expectedResultsJSON.get(key));
		    }
		}
		if (debug) log.info(actualResult.toString());
		if (debug) log.info(newExpectedResult.toString());
		vars.put(&quot;newExpectedResult&quot;,newExpectedResult.toString());
		vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
	} else {
		vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
	}
	if (debug) log.info(&quot;Store response JSON and validate response code - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2100&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}


</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Validate individual elements in JSON with that of the expected results" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//Validate individual elements in JSON
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONObject;
import com.github.wnameless.json.flattener.JsonFlattener;
try {
	Boolean debug;
	String errorCode=&quot;&quot;;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Validate individual elements in JSON with that of the expected results - beanshell starts&quot;);
	String testResult;
	String reasonForFailure=&quot;&quot;;
	if (vars.get(&quot;responseCodeValidation&quot;).equals(&quot;PASS&quot;)) {
		String jsonStringActualResults = prev.getResponseDataAsString().toString();
		if (debug) log.info(&quot;JSON String Expected Results&quot;);
		if (debug) log.info(vars.get(&quot;newExpectedResult&quot;));
		if (debug) log.info(&quot;JSON String Modified Results&quot;);
		Map checkMap = JsonFlattener.flattenAsMap(vars.get(&quot;newExpectedResult&quot;));
		JSONObject checkMapJSONObject = new JSONObject(checkMap.toString());
		Iterator checkKeys = checkMapJSONObject.keys();
		int emptyKey=0;
		int count=0;
		while (checkKeys.hasNext()) {
			count++;
			String checkKey = checkKeys.next();
			if (checkMapJSONObject.get(checkKey).toString().equals(&quot;{}&quot;)) {
				emptyKey++;
			}
		}
		String expectedResultsModified = &quot;{}&quot;;
		if (count!=emptyKey)
			expectedResultsModified = vars.get(&quot;newExpectedResult&quot;).replace(&quot;{},&quot;,&quot;&quot;).replace(&quot;{}]&quot;,&quot;]&quot;).replace(&quot;{}}&quot;,&quot;}&quot;)
			.replace(&quot;,]&quot;,&quot;]&quot;).replace(&quot;,}&quot;,&quot;}&quot;);
		if (debug) log.info(&quot;Expected Rsults modified&quot;);
		if (debug) log.info(expectedResultsModified);
		if (new JSONObject(expectedResultsModified).length() &gt; 0) {
				Map flattenedJsonMapActualResults = JsonFlattener.flattenAsMap(jsonStringActualResults);
				Map flattenedJsonMapExpectedResults = JsonFlattener.flattenAsMap(expectedResultsModified);
				JSONObject flatteneddActualResults = new JSONObject(flattenedJsonMapActualResults.toString());
				JSONObject flatteneddExpectedResults = new JSONObject(flattenedJsonMapExpectedResults.toString());
				if (debug) log.info(&quot;Expected Results&quot;);
			 	if (debug) log.info(flatteneddExpectedResults.toString());
				if (debug) log.info(&quot;Actual Results&quot;);
				if (debug) log.info(flatteneddActualResults.toString());
				Iterator newKeys = flatteneddExpectedResults.keys();
				while (newKeys.hasNext()) {
					String newKey = newKeys.next();
					if (flatteneddActualResults.has(newKey)) {
						Object expectedResultObject= flatteneddExpectedResults.get(newKey);
						Object actualResultObject = flatteneddActualResults.get(newKey);
						if (expectedResultObject instanceof String) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a String and its value is &quot;+String.valueOf(expectedResultObject)); 
							if (debug) log.info(&quot;Actual =&gt;&quot; +newKey+&quot; is a String and its value is &quot;+String.valueOf(actualResultObject)); 
							if (String.valueOf(actualResultObject).equals(&quot;null&quot;)) {
								actualResultObject=&quot;&quot;;
							}
							if (String.valueOf(expectedResultObject).equals(String.valueOf(actualResultObject))) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
						} else if (expectedResultObject instanceof Integer) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a Integer and its value is &quot;+String.valueOf(expectedResultObject));	
							if (debug) log.info(&quot;Actual =&gt;&quot;+newKey+&quot; is a Integer and its value is &quot;+String.valueOf(actualResultObject));			
							//double expected = (double)expectedResultObject;
							//double actual = (double) actualResultObject;
							double expected = (double) Integer.parseInt(String.valueOf(expectedResultObject));
							double actual = (double) Double.parseDouble(String.valueOf(actualResultObject));
							
							if (Double.compare(expected,actual) == 0) {
							//if (String.valueOf(expectedResultObject).equals(String.valueOf(actualResultObject))) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
						} else if (expectedResultObject instanceof Double) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a Double and its value is &quot;+String.valueOf(expectedResultObject));	
							if (debug) log.info(&quot;Actual =&gt;&quot;+newKey+&quot; is a Double and its value is &quot;+String.valueOf(actualResultObject));			
							if (Double.compare(expectedResultObject,actualResultObject) == 0) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
					
						} else if (expectedResultObject instanceof Boolean) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a Boolean and its value is &quot;+String.valueOf(expectedResultObject));	
							if (debug) log.info(&quot;Actual =&gt;&quot;+newKey+&quot; is a Boolean and its value is &quot;+String.valueOf(actualResultObject));			
					
							if (expectedResultObject==actualResultObject) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
						} 
						if (testResult.equals(&quot;FAIL&quot;)) {
							reasonForFailure = reasonForFailure.concat(&quot;|&quot;).concat(&quot;Expected value for &quot;).concat(newKey).concat(&quot; is &quot;).concat(String.valueOf(expectedResultObject)).concat(&quot; and actual value is &quot;).concat(String.valueOf(actualResultObject));
							if (debug) log.info(&quot;Reason For Failure: &quot;+reasonForFailure);
							//break;
						}
					} else {
						testResult = &quot;FAIL&quot;;
						reasonForFailure = reasonForFailure.concat(&quot;|&quot;).concat(newKey).concat(&quot; not present in the results JSON Object&quot;);
						//break;
					}
				}
		} else {
			testResult = &quot;PASS&quot;;
		}
	} else {
		testResult = &quot;FAIL&quot;;
		reasonForFailure = &quot;Actual response code received is &quot;+prev.getResponseCode();
	}
	if (reasonForFailure.length()&gt;0) testResult=&quot;FAIL&quot;;
////



//get_expectedResponseCode
int expectedResponseCode =0;
log.info(vars.get(&quot;expectedResultsArray&quot;));
JSONArray fetexpectedResponseCodeFromArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
int fetexpectedResponseCodeFromArraySize=fetexpectedResponseCodeFromArray.length();
int checkExpectedResponseCode = Integer.valueOf(vars.get(&quot;testScenarioNumber&quot;));
	for(int i=0;i&lt;fetexpectedResponseCodeFromArraySize;i++)
		{
			JSONObject newJSonObject = new JSONObject();
		
			newJSonObject = fetexpectedResponseCodeFromArray.getJSONObject((checkExpectedResponseCode-1));
			expectedResponseCode=newJSonObject.getInt(&quot;expectedResponseCode&quot;);	
		}
	if (debug) log.info(&quot;expectedResponseCode-:-&quot;+String.valueOf(expectedResponseCode));

	String actualResponseCode=&quot;NA&quot;;
	actualResponseCode =prev.getResponseCode();
 	
//	//Store Results in a csv file
	String resultToBeStored =vars.get(&quot;payloadInjectionDate&quot;).concat(&quot;,&quot;).concat(vars.get(&quot;payloadInjectionTime&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;moduleName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;payloadFilePath&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;jsonResultsFileName&quot;)).concat(&quot;,&quot;).concat(testResult).concat(&quot;,&quot;).concat(String.valueOf(expectedResponseCode)).concat(&quot;,&quot;).concat(actualResponseCode).concat(&quot;,&quot;).concat(vars.get(&quot;overallInputFile&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiMethod&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiFullPathValue&quot;)).concat(&quot;,&quot;).concat(reasonForFailure).concat(&quot;,&quot;).concat(vars.get(&quot;consentPerson&quot;));
	if (debug) log.info(resultToBeStored);
	f = new FileOutputStream(vars.get(&quot;apiResultsFileName&quot;),true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(resultToBeStored);
	f.close();
	//String overallResult = vars.get(&quot;apiTestResult&quot;);
	if (testResult.equals(&quot;FAIL&quot;) &amp;&amp; vars.get(&quot;apiTestResult&quot;).equals(&quot;PASS&quot;)) vars.put(&quot;apiTestResult&quot;,&quot;FAIL&quot;);
	if (debug) log.info(&quot;Validate individual elements in JSON with that of the expected results - beanshell ends&quot;); 
} catch (Exception e) {
	String errorCode=&quot;2200&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                    </hashTree>
                  </hashTree>
                </hashTree>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller_JSON" enabled="true">
                <stringProp name="IfController.condition">&quot;${fileType}&quot;==&quot;json&quot; &amp;&amp; &quot;${mysql}&quot;==&quot;n&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                  <stringProp name="IfController.condition">&quot;${testScenarioNumber}&quot;!=&quot;&lt;EOF&gt;&quot;</stringProp>
                  <boolProp name="IfController.evaluateAll">false</boolProp>
                </IfController>
                <hashTree>
                  <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Check JSON  file is available?" enabled="true">
                    <boolProp name="WAITING">true</boolProp>
                    <boolProp name="SUCCESFULL">true</boolProp>
                    <stringProp name="RESPONSE_CODE">200</stringProp>
                    <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                    <stringProp name="REQUEST_DATA">${expectedJsonPath}
${payloadJsonPath}

${jsonLoop}</stringProp>
                    <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                    <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                    <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                    <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                    <stringProp name="URL"></stringProp>
                    <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                  </kg.apc.jmeter.samplers.DummySampler>
                  <hashTree>
                    <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor_FileCheck" enabled="true">
                      <boolProp name="resetInterpreter">false</boolProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">//check_Json_File
import java.util.*;
String payloadJsonPath = vars.get(&quot;payloadJsonPath&quot;);
String expectedJsonPath=vars.get(&quot;expectedJsonPath&quot;);

String payloadJsonFileName = vars.get(&quot;payloadJSON&quot;);
String expectedJsonFileName = vars.get(&quot;expectedJSON&quot;);

String payloadFilePathString=payloadJsonPath.concat(payloadJsonFileName);
String expectedFilePathString=expectedJsonPath.concat(expectedJsonFileName);


ArrayList  listValue = new ArrayList();
listValue.add(payloadFilePathString);
listValue.add(expectedFilePathString);

vars.put(&quot;payloadFilePathString&quot;,payloadFilePathString);
vars.put(&quot;expectedFilePathString&quot;,expectedFilePathString);
// log.info(String.valueOf(listValue));

for(int i=0;i&lt;listValue.size();i++)
	{
	//log.info(listValue.get(i));
		
		File f = new File(listValue.get(i));
		if(f.exists() &amp;&amp; !f.isDirectory()) { 
		   vars.put(&quot;jsonFileCheck&quot;,&quot;y&quot;);
		   
		}
			else
			{
			log.info(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			 vars.put(&quot;fileCheck&quot;,&quot;n&quot;);
			 System.out.println(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			}
	}
	
</stringProp>
                    </BeanShellPreProcessor>
                    <hashTree/>
                  </hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${jsonLoop}</stringProp>
                  </LoopController>
                  <hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read data from payload tracker" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__CSVRead(${payloadTrackingFile},0)}|${__CSVRead(${payloadTrackingFile},1)}|${__CSVRead(${payloadTrackingFile},2)}|${__CSVRead(${payloadTrackingFile},3)}${__CSVRead(${payloadTrackingFile},next)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//testScenarioNumber,payloadFilePath,expectedResultsFilePath,urlInputFieldsFilePath
String responseMsg = prev.getResponseDataAsString();
log.info(responseMsg);
String[] responseMsgSplit = responseMsg.split(&quot;\\|&quot;);
vars.put(&quot;testScenarioNumber&quot;,responseMsgSplit[0]);
vars.put(&quot;payloadFilePath&quot;,responseMsgSplit[1]);
vars.put(&quot;expectedResultsFilePath&quot;,responseMsgSplit[2]);
vars.put(&quot;urlInputFieldsFilePath&quot;,responseMsgSplit[3]);
log.info(responseMsgSplit[0]);
log.info(responseMsgSplit[1]);
log.info(responseMsgSplit[2]);
log.info(responseMsgSplit[3]);</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                    </hashTree>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                      <stringProp name="IfController.condition">&quot;${jsonFileCheck}&quot;==&quot;y&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Json Payload File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${payloadFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Json Payload File
import org.json.JSONArray;
import org.json.JSONObject;

JSONArray newInputFieldsJsonArray = new JSONArray();
String payloadDataArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(payloadDataArray);
log.info(String.valueOf(newJsonArray.length()));
int size=newJsonArray.length();
vars.put(&quot;numberOfRowsInCSV&quot;,String.valueOf(size));
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));
for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;apiName&quot;);
	log.info(apiName);
	Object payloadCheck =newJsonObject.get(&quot;payload&quot;);

	//check - &gt; match with apiname
	if(apiName.equalsIgnoreCase(testapiName))
	{		
			jsonPayloadFileName = vars.get(&quot;timeStampedJsonPayloadPath&quot;).concat(&quot;testScenario_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
			Object payloadCheck =newJsonObject.get(&quot;payload&quot;);
			f = new FileOutputStream(jsonPayloadFileName, false);
			p = new PrintStream(f); 
			this.interpreter.setOut(p); 
			print(payloadCheck);
			f.close();	
			vars.put(&quot;payloadFilePath&quot;,jsonPayloadFileName);	
			vars.put(&quot;jsonPayload&quot;,String.valueOf(payloadCheck));

			//If = scenario -&gt; get apimethod and apipath from json
			if(vars.get(&quot;scenario&quot;).equalsIgnoreCase(&quot;y&quot;))
			{
			String apiMethod = newJsonObject.get(&quot;apiMethod&quot;);
			String apiPath= newJsonObject.get(&quot;apiPath&quot;);
			vars.put(&quot;apiMethod&quot;,apiMethod);
			vars.put(&quot;apiPath&quot;,apiPath);	
			}
			break;
	}
		
}

</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Json Expected File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${expectedFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Json Expected File
import org.json.JSONArray;
import org.json.JSONObject;

JSONArray newExpectedResultsArray = new JSONArray();
String expectedResultArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(expectedResultArray);
//log.info(payloadDateArray);
log.info(String.valueOf(newJsonArray.length()));
//JSONObject newJsonObject = new JSONObject();
int size=newJsonArray.length();
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));
for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;apiName&quot;);	
	Object expectedCheck =newJsonObject.get(&quot;expected&quot;);
//	Object ignoreKeys = newJsonObject.get(&quot;ignore&quot;);
	//Check the expected result is Array ? or Object?
	if(expectedCheck instanceof JSONObject)
		{
//			log.info(&quot;---------&gt;jsonObject&quot;);
		 vars.put(&quot;jsonType&quot;,&quot;jsonObject&quot;);
		}else if(expectedCheck instanceof JSONArray)
			{
//				log.info(&quot;---------&gt;jsonArray&quot;);
			 vars.put(&quot;jsonType&quot;,&quot;jsonArray&quot;);	
			}
	
	vars.put(&quot;expectedResult&quot;,String.valueOf(expectedCheck));	
//	log.info(&quot;expectedObject--&gt;&quot;+String.valueOf(expectedCheck));	
	newExpectedResultsArray.put(expectedCheck);	
	if(apiName.equalsIgnoreCase(testapiName))
	{
		//log.info(&quot;expectedObject--&gt;AfterIf&quot;+String.valueOf(expectedCheck));
		//log.info(&quot;expectedObject--apiName-&gt;&quot;+apiName);
		vars.put(&quot;apiNameExpected&quot;,testapiName);
		Object expectedCheck =newJsonObject.get(&quot;expected&quot;);

		//ignoreKeys
//		JSONArray ignoreKeys = new JSONArray();
		Object ignoreKeys=newJsonObject.get(&quot;ignore&quot;);
		JSONArray commonIgnoreArray =newJsonObject.get(&quot;commonIgnore&quot;);
		vars.put(&quot;commonIgnoreArray&quot;,String.valueOf(commonIgnoreArray));
		vars.put(&quot;ignoreKeysArray&quot;,String.valueOf(ignoreKeys));
		log.info(String.valueOf(ignoreKeys));

		// selectedFields
		String apiNameCheck = vars.get(&quot;apiName&quot;);
		String selectedFieldsJson = vars.get(&quot;selectedFieldsJsonArray&quot;);
//		log.info(selectedFieldsJson);
		JSONArray selectedFieldsJsonArray = new JSONArray(selectedFieldsJson);
		int selectedFieldsJsonArraySize= selectedFieldsJsonArray.length();
//		log.info(String.valueOf(selectedFieldsJsonArraySize));
		for(int i=0;i&lt;selectedFieldsJsonArraySize;i++)
		{
			String arrayAPIName = selectedFieldsJsonArray.get(i);
//			log.info(arrayAPIName);
			if(apiNameCheck.equalsIgnoreCase(arrayAPIName))
			{
			JSONArray selectedFieldJSONkeysArray =newJsonObject.get(&quot;selectedFieldJSONkeys&quot;);
//			log.info(&quot;selectedFieldJSONkeysArray------&gt;&gt;&quot;+String.valueOf(selectedFieldJSONkeysArray));
			vars.put(&quot;selectedFieldJSONkeysArray&quot;,String.valueOf(selectedFieldJSONkeysArray));
				break;
			}
			
		}
		

		
		
		String expectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;).concat(&quot;expectedResults_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		
		//log.info(&quot;----&gt;&quot;+expectedResultsFileName);
		f4 = new FileOutputStream(expectedResultsFileName, false);
		p4 = new PrintStream(f4); 
		this.interpreter.setOut(p4); 
		print(expectedCheck);
		f4.close();	
		vars.put(&quot;jsonExpected&quot;,String.valueOf(expectedCheck));
		break;
	}		
}
//vars.put(&quot;expectedResultsArray&quot;,String.valueOf(newExpectedResultsArray));
//log.info(String.valueOf(newExpectedResultsArray));
</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read URL Parameter into a variable" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${urlInputFieldsFilePath},,urlInputParameters)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree/>
                      <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler - Check elapsed time" enabled="true">
                        <stringProp name="BeanShellSampler.query">//Check Elapsed Time
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
long startTime=Long.valueOf(vars.get(&quot;startTime_&quot;+ctx.getThreadNum()));
double diff = (timeMilli-startTime)/60000;

if (diff &gt;= 18.0) {
	vars.put(&quot;relogin&quot;,&quot;1&quot;);
} else {
	vars.put(&quot;relogin&quot;,&quot;0&quot;);
}
</stringProp>
                        <stringProp name="BeanShellSampler.filename"></stringProp>
                        <stringProp name="BeanShellSampler.parameters"></stringProp>
                        <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                      </BeanShellSampler>
                      <hashTree/>
                      <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If elapsed time" enabled="true">
                        <stringProp name="IfController.condition">&quot;${relogin}&quot;==&quot;1&quot;</stringProp>
                        <boolProp name="IfController.evaluateAll">false</boolProp>
                      </IfController>
                      <hashTree>
                        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token " enabled="true">
                          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                            <collectionProp name="Arguments.arguments">
                              <elementProp name="" elementType="HTTPArgument">
                                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                                <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                                <stringProp name="Argument.metadata">=</stringProp>
                              </elementProp>
                            </collectionProp>
                          </elementProp>
                          <stringProp name="HTTPSampler.domain">${server}</stringProp>
                          <stringProp name="HTTPSampler.port"></stringProp>
                          <stringProp name="HTTPSampler.protocol">http</stringProp>
                          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                          <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                          <stringProp name="HTTPSampler.method">POST</stringProp>
                          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                          <stringProp name="HTTPSampler.response_timeout"></stringProp>
                          <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                        </HTTPSamplerProxy>
                        <hashTree>
                          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                            <collectionProp name="HeaderManager.headers">
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">Content-Type</stringProp>
                                <stringProp name="Header.value">application/json</stringProp>
                              </elementProp>
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                                <stringProp name="Header.value">testground</stringProp>
                              </elementProp>
                            </collectionProp>
                          </HeaderManager>
                          <hashTree/>
                          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                            <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                            <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                            <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                            <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                          </JSONPostProcessor>
                          <hashTree/>
                          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - timeCheck" enabled="true">
                            <boolProp name="resetInterpreter">false</boolProp>
                            <stringProp name="parameters"></stringProp>
                            <stringProp name="filename"></stringProp>
                            <stringProp name="script">//RecordStartTime2
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
vars.put(&quot;relogin&quot;,&quot;0&quot;);</stringProp>
                          </BeanShellPostProcessor>
                          <hashTree/>
                        </hashTree>
                      </hashTree>
                      <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="API Name - ${apiName}" enabled="true">
                        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                          <collectionProp name="Arguments.arguments"/>
                        </elementProp>
                        <stringProp name="HTTPSampler.domain">${server}</stringProp>
                        <stringProp name="HTTPSampler.port">${port}</stringProp>
                        <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
                        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                        <stringProp name="HTTPSampler.path"></stringProp>
                        <stringProp name="HTTPSampler.method">POST</stringProp>
                        <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                        <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                        <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                        <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                        <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                        <stringProp name="HTTPSampler.connect_timeout">120000</stringProp>
                        <stringProp name="HTTPSampler.response_timeout"></stringProp>
                        <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                      </HTTPSamplerProxy>
                      <hashTree>
                        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                          <collectionProp name="HeaderManager.headers"/>
                        </HeaderManager>
                        <hashTree/>
                        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Manage HTTP  Headers and api method for the REST API" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">
//Add any additional headers as required
import org.apache.jmeter.protocol.http.control.Header;
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell starts&quot;);
	sampler.setMethod(vars.get(&quot;apiMethod&quot;));	
     JSONObject urlInputFields = new JSONObject(vars.get(&quot;urlInputParameters&quot;));// vars.get(&quot;urlInputParameters&quot;)
	 log.info(&quot;URL Input fields: &quot;+urlInputFields.toString());
	Object aObj = urlInputFields.get(&quot;urlParameter&quot;);
	String urlParameterValue=null;
	String apiFullPathValue =&quot;NA&quot;;
	if(aObj instanceof Integer){
   if (debug) log.info(&quot;Integer : &quot;+String.valueOf(aObj));
     urlParameterValue=urlInputFields.getInt(&quot;urlParameter&quot;).toString();
}
else
{
	if (debug) log.info(&quot;String :&quot;+String.valueOf(aObj));
	urlParameterValue=urlInputFields.getString(&quot;urlParameter&quot;);
}
if (debug) log.info(&quot;---&quot;+urlParameterValue);
	if (urlParameterValue.length()&gt;0 &amp;&amp; !urlParameterValue.equals(null) &amp;&amp; !urlParameterValue.equals(&quot;NA&quot;))
	{
//		if (debug)log.info(&quot;--------------path with parameter&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue));
		apiFullPathValue = vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue);
	} else {
//		if (debug) log.info(&quot;--------------only path&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;));		
		apiFullPathValue = vars.get(&quot;apiPath&quot;);
	}

			
	vars.put(&quot;apiFullPathValue&quot;,apiFullPathValue);
//	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
		if (vars.get(&quot;jsonPayload&quot;).length()&gt;5) {
			sampler.setPostBodyRaw(true);
			sampler.addNonEncodedArgument(&quot;&quot;,vars.get(&quot;jsonPayload&quot;),&quot;&quot;);

			//log.info(&quot;payload File is----&gt;&quot;+vars.get(&quot;jsonPayload&quot;));
		}
//	}
	String apiHeadersString = &quot;&quot;;
	if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;)) apiHeadersString=vars.get(&quot;apiHeadersGETPUT&quot;); 
	else apiHeadersString=vars.get(&quot;apiHeaders&quot;);
	log.info(&quot;API Header String: &quot;+apiHeadersString);
       
	int countOfExistingHeaders = sampler.getHeaderManager().size();
	if (debug) log.info(&quot;Count of headers: &quot;+String.valueOf(countOfExistingHeaders));
	if (countOfExistingHeaders==0) {
		JSONObject apiHeadersObject = new JSONObject(apiHeadersString);		
		Iterator newKeys = apiHeadersObject.keys();
		while (newKeys.hasNext()) {
			String newKey = newKeys.next();
			sampler.getHeaderManager().add(new Header(newKey,apiHeadersObject.getString(newKey)));
		}
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	} else {
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	}

	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2300&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}
</stringProp>
                        </BeanShellPreProcessor>
                        <hashTree/>
                        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Store the payload injection date and time" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Store the payload injection date and time
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String payloadInjectionDate = dateFormatter.format(cal.getTime());
	String payloadInjectionTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;payloadInjectionDate&quot;,payloadInjectionDate);
	vars.put(&quot;payloadInjectionTime&quot;,payloadInjectionTime);
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2400&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode);
	f.close();
}</stringProp>
                        </BeanShellPreProcessor>
                        <hashTree/>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Store response JSON and validate response code /  compare JSON" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Store results JSON in the appropriate folder
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
import java.util.regex.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;
import java.util.Map;
import jsonComparator.*;
import ignore.*;
import selectedFieldsJson.*;
jsonComparator1 jComparator = new jsonComparator1();
ignore ignoreCommon = new ignore();
selectedFieldsJson selectedFieldsClassObject = new selectedFieldsJson();


try {
	 Object responseMsg1;
	 Object responseMsg2;
	 Object responseMsg3;
	 Object responseMsg4;
	 
	String jsonResultsFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(vars.get(&quot;apiNameExpected&quot;)).concat(&quot;.json&quot;);//	
	//log.info(&quot;jsonResultsFileName-----&gt;&quot;+jsonResultsFileName);
	
	f = new FileOutputStream(jsonResultsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(prev.getResponseDataAsString());
	f.close();

	//get_expectedResponseCode
	String reasonForFailure=&quot;&quot;;
	int expectedResponseCode =0;
	//log.info(vars.get(&quot;expectedResultsArray&quot;));
	String responseType =&quot;JSON&quot;; 
	JSONArray fetexpectedResponseCodeFromArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
	int fetexpectedResponseCodeFromArraySize=fetexpectedResponseCodeFromArray.length();
	int checkExpectedResponseCode = Integer.valueOf(vars.get(&quot;testScenarioNumber&quot;));
		for(int i=0;i&lt;fetexpectedResponseCodeFromArraySize;i++)
			{
				JSONObject newJSonObject = new JSONObject();		
				newJSonObject = fetexpectedResponseCodeFromArray.getJSONObject((checkExpectedResponseCode-1));
				expectedResponseCode=newJSonObject.getInt(&quot;expectedResponseCode&quot;);	
			}

		//JSONObject newExpectedResults after trimming the expected response code
		if (String.valueOf(expectedResponseCode).equals(prev.getResponseCode())) {
			vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
			
			//jsonComparator
		 	String responseMsg= prev.getResponseDataAsString();
		 	 try
				 {
				 	JSONObject newJsonObject2 = new JSONObject(responseMsg);
				 	responseMsg1=newJsonObject2;
	 	
					 } catch (Exception e) {try
										 {	
										 	JSONArray newJsonArray2 = new JSONArray(responseMsg);
										 	responseMsg1= newJsonArray2;
		
										 }catch (Exception e) {
//													 		log.info(&quot;String-------&gt;&quot;);
													 		responseType=&quot;String&quot;;
													 		responseMsg2= responseMsg;
													 		}					 		 	
					 					}
		 	
		 	
		 	if(vars.get(&quot;jsonType&quot;).equalsIgnoreCase(&quot;jsonObject&quot;))
		 	{
//		 		log.info(&quot;inside of if  object&quot;);
		 	 JSONObject newJsonObject = new JSONObject(vars.get(&quot;expectedResult&quot;));
		 	responseMsg2 = newJsonObject;
		 	}else if(vars.get(&quot;jsonType&quot;).equalsIgnoreCase(&quot;jsonArray&quot;))
			 	{
//			 		log.info(&quot;inside of if  array&quot;);
			 	 JSONArray newJsonArray = new JSONArray(vars.get(&quot;expectedResult&quot;));
			 	 responseMsg2 = newJsonArray;
			 	}


						responseMsg3 =responseMsg1;
						responseMsg4 =responseMsg2;
	
		 	 //log.info(String.valueOf(responseMsg2.length()));
		 	    String checkExpectedLength =vars.get(&quot;expectedResult&quot;);
				if (checkExpectedLength.length()&gt;5)
		 	 	{	

					if(responseType.equalsIgnoreCase(&quot;JSON&quot;))
					{			
						//Ignore common
						String jsonTypeIs =vars.get(&quot;jsonType&quot;);
						JSONArray JsonIgnoreCommonArray = new JSONArray(vars.get(&quot;commonIgnoreArray&quot;));

//						log.info(String.valueOf(&quot;----&gt;&quot;+JsonIgnoreCommonArray.length()));
						int commonIgnoreSize=0;
						commonIgnoreSize =JsonIgnoreCommonArray.length();
						if(commonIgnoreSize&gt;0)
						{
						
//						JsonIgnoreCommonArray.put(&quot;lastModifiedOn&quot;);
//						JsonIgnoreCommonArray.put(&quot;createdOn&quot;);
						
						responseMsg1 = ignoreCommon.commonIgnore(jsonTypeIs,responseMsg1,JsonIgnoreCommonArray);
						responseMsg2 = ignoreCommon.commonIgnore(jsonTypeIs,responseMsg2,JsonIgnoreCommonArray);
						}
						
						JSONArray newJSONArray = new JSONArray();
						newJSONArray.put(responseMsg1);
						newJSONArray.put(responseMsg2);
						
						JSONArray ignoreKeysArray = new JSONArray(vars.get(&quot;ignoreKeysArray&quot;));
						newJSONArray.put(ignoreKeysArray);

//						log.info(&quot;---JAR---Array&quot;+String.valueOf(newJSONArray));
						
					 	String jsoncompareResult =String.valueOf(jComparator.areEqual(newJSONArray));
					 	//String.valueOf(jComparator.areEqual(responseMsg1,responseMsg2));
					 	log.info(&quot;Result---&gt;&quot;+jsoncompareResult);	
						log.info(String.valueOf(newJSONArray));
					 	if(jsoncompareResult.equalsIgnoreCase(&quot;True&quot;)){
							vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
							} else
							{
							vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;);	
							}
					}else
								 	{
								 		vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 						 		 
								 	}

	//selected field validation
	String jsonFileWriteCheck = vars.get(&quot;responseCodeValidation&quot;);
	if(jsonFileWriteCheck.equalsIgnoreCase(&quot;FAIL&quot;))
	{
		String apiNameCheck = vars.get(&quot;apiName&quot;);
		String selectedFieldsJson = vars.get(&quot;selectedFieldsJsonArray&quot;);
		JSONArray selectedFieldsJsonArray = new JSONArray(selectedFieldsJson);
		int selectedFieldsJsonArraySize= selectedFieldsJsonArray.length();
//		log.info(&quot;selectedFieldsJsonArraySize---&gt;&quot;+String.valueOf(selectedFieldsJsonArraySize));
		for(int i=0;i&lt;selectedFieldsJsonArraySize;i++)
		{
			String arrayAPIName = selectedFieldsJsonArray.get(i);
			if(apiNameCheck.equalsIgnoreCase(arrayAPIName))
			{
				String jsonTypeIs =vars.get(&quot;jsonType&quot;);				
				String selectedkeys =vars.get(&quot;selectedFieldJSONkeysArray&quot;);
				JSONArray newseletedArrayKeys = new JSONArray(vars.get(&quot;selectedFieldJSONkeysArray&quot;));
				responseMsg1=selectedFieldsClassObject.checkReturn(jsonTypeIs,responseMsg3,newseletedArrayKeys);
//				log.info(&quot;responseMsg1&quot;+responseMsg1);
				responseMsg2=selectedFieldsClassObject.checkReturn(jsonTypeIs,responseMsg4,newseletedArrayKeys);
//				log.info(&quot;responseMsg2&quot;+responseMsg2);
				JSONArray ignoreKeysArray = new JSONArray();
				JSONArray newJSONArray = new JSONArray();
						newJSONArray.put(responseMsg1);
						newJSONArray.put(responseMsg2);
						newJSONArray.put(ignoreKeysArray);
						String jsoncompareResult =String.valueOf(jComparator.areEqual(newJSONArray));
//						log.info(&quot;selected fiels compar -----&gt;&quot;+jsoncompareResult);
						if(jsoncompareResult.equalsIgnoreCase(&quot;True&quot;)){
							vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
							} else
							{
							vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;);	
							}					
				break;
			}
			
		}
		

		
	}
	
								 	
							//Write mismatch json actual and expected file 
							jsonFileWriteCheck = vars.get(&quot;responseCodeValidation&quot;);							
							if(jsonFileWriteCheck.equalsIgnoreCase(&quot;FAIL&quot;))
							{
								String jsonCompareFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(&quot;apiActualExpectedFileName&quot;).concat(vars.get(&quot;apiNameExpected&quot;)).concat(&quot;.txt&quot;);
										log.info(&quot;jsonCompareFileName&quot;+jsonCompareFileName);
										
								 		f = new FileOutputStream(jsonCompareFileName,true);
										p = new PrintStream(f); 
										this.interpreter.setOut(p);
										print(&quot;\nActual Result:------&gt; &quot;+responseMsg1);
										print(&quot;\nExpected Result:----&gt; &quot;+responseMsg2);					
										f.close();
								 		 reasonForFailure=&quot;Expected result not match with actual result:  &quot;;
								 		 reasonForFailure=reasonForFailure.concat(jsonCompareFileName);	
}



								 	
			 	 		}
		 	 	
			
		} else {
			 reasonForFailure=&quot;Actual response code received is &quot;;
			 reasonForFailure=reasonForFailure.concat(String.valueOf(prev.getResponseCode()));			 
			 vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
			 //testResult=&quot;FAIL&quot;;
		}	
	
		String actualResponseCode=&quot;NA&quot;;
		actualResponseCode =prev.getResponseCode();	 	
		//Store Results in a csv file
		String resultToBeStored =vars.get(&quot;payloadInjectionDate&quot;).concat(&quot;,&quot;).concat(vars.get(&quot;payloadInjectionTime&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;moduleName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;payloadFilePath&quot;)).concat(&quot;,&quot;).concat(jsonResultsFileName).concat(&quot;,&quot;).concat(vars.get(&quot;responseCodeValidation&quot;)).concat(&quot;,&quot;).concat(String.valueOf(expectedResponseCode)).concat(&quot;,&quot;).concat(actualResponseCode).concat(&quot;,&quot;).concat(vars.get(&quot;overallInputFile&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiMethod&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiFullPathValue&quot;)).concat(&quot;,&quot;).concat(reasonForFailure).concat(&quot;,&quot;).concat(vars.get(&quot;consentPerson&quot;));
	////	if (debug)log.info(&quot;*****&quot;+resultToBeStored);
		f = new FileOutputStream(vars.get(&quot;apiResultsFileName&quot;),true);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		print(resultToBeStored);
		f.close();
		
	 
} catch (Exception e) {
	String errorCode=&quot;2500&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;JSON Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}


</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                        <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="true">
                          <stringProp name="ConstantTimer.delay">30000</stringProp>
                        </ConstantTimer>
                        <hashTree/>
                      </hashTree>
                    </hashTree>
                  </hashTree>
                </hashTree>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller_MYSQL" enabled="true">
                <stringProp name="IfController.condition">&quot;${fileType}&quot;==&quot;json&quot; &amp;&amp; &quot;${mysql}&quot;==&quot;y&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="Counter" enabled="true">
                  <stringProp name="CounterConfig.start">1</stringProp>
                  <stringProp name="CounterConfig.end"></stringProp>
                  <stringProp name="CounterConfig.incr">1</stringProp>
                  <stringProp name="CounterConfig.name">firstValidation</stringProp>
                  <stringProp name="CounterConfig.format"></stringProp>
                  <boolProp name="CounterConfig.per_user">false</boolProp>
                </CounterConfig>
                <hashTree/>
                <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                  <stringProp name="IfController.condition">&quot;${testScenarioNumber}&quot;!=&quot;&lt;EOF&gt;&quot;</stringProp>
                  <boolProp name="IfController.evaluateAll">false</boolProp>
                </IfController>
                <hashTree>
                  <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Check SQL query input  file is available?" enabled="true">
                    <boolProp name="WAITING">true</boolProp>
                    <boolProp name="SUCCESFULL">true</boolProp>
                    <stringProp name="RESPONSE_CODE">200</stringProp>
                    <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                    <stringProp name="REQUEST_DATA">${expectedJsonPath}
${payloadJsonPath}

${jsonLoop}</stringProp>
                    <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                    <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                    <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                    <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                    <stringProp name="URL"></stringProp>
                    <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                  </kg.apc.jmeter.samplers.DummySampler>
                  <hashTree>
                    <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor_FileCheck" enabled="true">
                      <boolProp name="resetInterpreter">false</boolProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">//check_Json_File
import java.util.*;
String payloadJsonPath = vars.get(&quot;payloadJsonPath&quot;);
String expectedJsonPath=vars.get(&quot;expectedJsonPath&quot;);

String payloadJsonFileName = vars.get(&quot;payloadJSON&quot;);
String expectedJsonFileName = vars.get(&quot;expectedJSON&quot;);

String payloadFilePathString=payloadJsonPath.concat(payloadJsonFileName);
String expectedFilePathString=expectedJsonPath.concat(expectedJsonFileName);


ArrayList  listValue = new ArrayList();
listValue.add(payloadFilePathString);
listValue.add(expectedFilePathString);

vars.put(&quot;payloadFilePathString&quot;,payloadFilePathString);
vars.put(&quot;expectedFilePathString&quot;,expectedFilePathString);
// log.info(String.valueOf(listValue));

for(int i=0;i&lt;listValue.size();i++)
	{
	//log.info(listValue.get(i));
		
		File f = new File(listValue.get(i));
		if(f.exists() &amp;&amp; !f.isDirectory()) { 
		   vars.put(&quot;jsonFileCheck&quot;,&quot;y&quot;);
		   
		}
			else
			{
			log.info(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			 vars.put(&quot;fileCheck&quot;,&quot;n&quot;);
			 System.out.println(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			}
	}
	
</stringProp>
                    </BeanShellPreProcessor>
                    <hashTree/>
                  </hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${jsonLoop}</stringProp>
                  </LoopController>
                  <hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read data from payload tracker" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__CSVRead(${payloadTrackingFile},0)}|${__CSVRead(${payloadTrackingFile},1)}|${__CSVRead(${payloadTrackingFile},2)}|${__CSVRead(${payloadTrackingFile},3)}${__CSVRead(${payloadTrackingFile},next)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//testScenarioNumber,payloadFilePath,expectedResultsFilePath,urlInputFieldsFilePath
String responseMsg = prev.getResponseDataAsString();
log.info(responseMsg);
String[] responseMsgSplit = responseMsg.split(&quot;\\|&quot;);
vars.put(&quot;testScenarioNumber&quot;,responseMsgSplit[0]);
vars.put(&quot;payloadFilePath&quot;,responseMsgSplit[1]);
vars.put(&quot;expectedResultsFilePath&quot;,responseMsgSplit[2]);
vars.put(&quot;urlInputFieldsFilePath&quot;,responseMsgSplit[3]);
log.info(responseMsgSplit[0]);
log.info(responseMsgSplit[1]);
log.info(responseMsgSplit[2]);
log.info(responseMsgSplit[3]);</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                    </hashTree>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                      <stringProp name="IfController.condition">&quot;${jsonFileCheck}&quot;==&quot;y&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Mysql Query File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${payloadFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Mysqlquery File
import org.json.JSONArray;
import org.json.JSONObject;
try
{
JSONArray newInputFieldsJsonArray = new JSONArray();
String payloadDataArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(payloadDataArray);
log.info(String.valueOf(newJsonArray.length()));
int size=newJsonArray.length();
vars.put(&quot;numberOfRowsInCSV&quot;,String.valueOf(size));
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));

for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;queryName&quot;);
//	log.info(apiName);
//	Object mysqlQuery =newJsonObject.get(&quot;mysqlQuery&quot;);

	//check - &gt; match with apiname
	if(apiName.equalsIgnoreCase(testapiName))
	{		
			jsonPayloadFileName = vars.get(&quot;timeStampedJsonPayloadPath&quot;).concat(&quot;mysqlQuery__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
			Object mysqlQuery =newJsonObject.get(&quot;mysqlQuery&quot;);
			f = new FileOutputStream(jsonPayloadFileName, false);
			p = new PrintStream(f); 
			this.interpreter.setOut(p); 
			print(mysqlQuery);
			f.close();	
			vars.put(&quot;payloadFilePath&quot;,jsonPayloadFileName);	
			vars.put(&quot;mysqlQuery&quot;,String.valueOf(mysqlQuery));
			vars.put(&quot;testapiName&quot;,testapiName);

			//If = scenario -&gt; get apimethod and apipath from json
//			if(vars.get(&quot;scenario&quot;).equalsIgnoreCase(&quot;y&quot;))
//			{
//			String apiMethod = newJsonObject.get(&quot;apiMethod&quot;);
//			String apiPath= newJsonObject.get(&quot;apiPath&quot;);
//			vars.put(&quot;apiMethod&quot;,apiMethod);
//			vars.put(&quot;apiPath&quot;,apiPath);	
//			}
			break;
	}
		
}
}catch (Exception e) {
	String errorCode=&quot;2600&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}

</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Expected Table  File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${expectedFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Expected Table file
import org.json.JSONArray;
import org.json.JSONObject;

JSONArray newExpectedResultsArray = new JSONArray();
String expectedResultArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(expectedResultArray);
log.info(String.valueOf(newJsonArray.length()));
int size=newJsonArray.length();
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));
for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;queryName&quot;);	
	Object expectedCheck =newJsonObject.get(&quot;expectedTableValue&quot;);
	
	//Check the expected result is Array ? or Object?
	if(expectedCheck instanceof JSONObject)
		{
		 vars.put(&quot;jsonType&quot;,&quot;jsonObject&quot;);
		}else if(expectedCheck instanceof JSONArray)
			{
			 vars.put(&quot;jsonType&quot;,&quot;jsonArray&quot;);	
//			 log.info(&quot;---------expectedTableValue-mysql query-------&quot;);
			}
	
	vars.put(&quot;expectedResult&quot;,String.valueOf(expectedCheck));	
	newExpectedResultsArray.put(expectedCheck);	
	if(apiName.equalsIgnoreCase(testapiName))
	{
		vars.put(&quot;quaryNameExpected&quot;,testapiName);
		Object expectedCheck =newJsonObject.get(&quot;expectedTableValue&quot;);

		//ignoreKeys
//		Object ignoreKeys=newJsonObject.get(&quot;ignore&quot;);
//		JSONArray commonIgnoreArray =newJsonObject.get(&quot;commonIgnore&quot;);
//		vars.put(&quot;commonIgnoreArray&quot;,String.valueOf(commonIgnoreArray));
//		vars.put(&quot;ignoreKeysArray&quot;,String.valueOf(ignoreKeys));

		String expectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;).concat(&quot;expectedTableResults__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		
		f4 = new FileOutputStream(expectedResultsFileName, false);
		p4 = new PrintStream(f4); 
		this.interpreter.setOut(p4); 
		print(expectedCheck);
		f4.close();	
		vars.put(&quot;expectedTableValue&quot;,String.valueOf(expectedCheck));
		break;
	}		
}

</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler - Check elapsed time" enabled="true">
                        <stringProp name="BeanShellSampler.query">//Check Elapsed Time
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
long startTime=Long.valueOf(vars.get(&quot;startTime_&quot;+ctx.getThreadNum()));
double diff = (timeMilli-startTime)/60000;

if (diff &gt;= 18.0) {
	vars.put(&quot;relogin&quot;,&quot;1&quot;);
} else {
	vars.put(&quot;relogin&quot;,&quot;0&quot;);
}
</stringProp>
                        <stringProp name="BeanShellSampler.filename"></stringProp>
                        <stringProp name="BeanShellSampler.parameters"></stringProp>
                        <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                      </BeanShellSampler>
                      <hashTree/>
                      <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If elapsed time" enabled="true">
                        <stringProp name="IfController.condition">&quot;${relogin}&quot;==&quot;1&quot;</stringProp>
                        <boolProp name="IfController.evaluateAll">false</boolProp>
                      </IfController>
                      <hashTree>
                        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token " enabled="true">
                          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                            <collectionProp name="Arguments.arguments">
                              <elementProp name="" elementType="HTTPArgument">
                                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                                <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                                <stringProp name="Argument.metadata">=</stringProp>
                              </elementProp>
                            </collectionProp>
                          </elementProp>
                          <stringProp name="HTTPSampler.domain">${server}</stringProp>
                          <stringProp name="HTTPSampler.port"></stringProp>
                          <stringProp name="HTTPSampler.protocol">http</stringProp>
                          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                          <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                          <stringProp name="HTTPSampler.method">POST</stringProp>
                          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                          <stringProp name="HTTPSampler.response_timeout"></stringProp>
                          <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                        </HTTPSamplerProxy>
                        <hashTree>
                          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                            <collectionProp name="HeaderManager.headers">
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">Content-Type</stringProp>
                                <stringProp name="Header.value">application/json</stringProp>
                              </elementProp>
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                                <stringProp name="Header.value">testground</stringProp>
                              </elementProp>
                            </collectionProp>
                          </HeaderManager>
                          <hashTree/>
                          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                            <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                            <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                            <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                            <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                          </JSONPostProcessor>
                          <hashTree/>
                          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - timeCheck" enabled="true">
                            <boolProp name="resetInterpreter">false</boolProp>
                            <stringProp name="parameters"></stringProp>
                            <stringProp name="filename"></stringProp>
                            <stringProp name="script">//RecordStartTime2
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
vars.put(&quot;relogin&quot;,&quot;0&quot;);</stringProp>
                          </BeanShellPostProcessor>
                          <hashTree/>
                        </hashTree>
                      </hashTree>
                      <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get Table Values from My SQL" enabled="true">
                        <stringProp name="dataSource">linearExpansion</stringProp>
                        <stringProp name="query">${mysqlQuery}</stringProp>
                        <stringProp name="queryArguments"></stringProp>
                        <stringProp name="queryArgumentsTypes"></stringProp>
                        <stringProp name="queryTimeout"></stringProp>
                        <stringProp name="queryType">Select Statement</stringProp>
                        <stringProp name="resultSetHandler">Store as String</stringProp>
                        <stringProp name="resultVariable">resultSet</stringProp>
                        <stringProp name="variableNames">combinationId,objectValue</stringProp>
                        <stringProp name="resultSetMaxRows"></stringProp>
                      </JDBCSampler>
                      <hashTree>
                        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Store the payload injection date and time" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Store the payload injection date and time
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String payloadInjectionDate = dateFormatter.format(cal.getTime());
	String payloadInjectionTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;payloadInjectionDate&quot;,payloadInjectionDate);
	vars.put(&quot;payloadInjectionTime&quot;,payloadInjectionTime);
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2700&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode);
	f.close();
}</stringProp>
                        </BeanShellPreProcessor>
                        <hashTree/>
                        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">String  firstValidationvalue = vars.get(&quot;firstValidation&quot;);
log.info(&quot;firstValidationvalue-----&gt;&quot;+firstValidationvalue);

if(firstValidationvalue.equalsIgnoreCase(&quot;1&quot;))
{
vars.put(&quot;firstValidationvalue&quot;,&quot;10000&quot;);
}
else
{
vars.put(&quot;firstValidationvalue&quot;,&quot;1000&quot;);
}
</stringProp>
                        </BeanShellPreProcessor>
                        <hashTree/>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Count of Results" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">;//validate table result
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.*;
import jsonComparator.*;
try
{
	
jsonComparator1 jComparator = new jsonComparator1();

String jsoncompareResult =&quot;NA&quot;;
String responseCodeValidation=&quot;NA&quot;;
String jsoncompareResult=&quot;FALSE&quot;;
int expectedResponseCode =0;
String reasonForFailure = &quot;&quot;;
String responseMsg =&quot;NA&quot;;

String responsecode = prev.getResponseCode();
String jsonResultsFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(vars.get(&quot;quaryNameExpected&quot;)).concat(&quot;.json&quot;);//	

	f = new FileOutputStream(jsonResultsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(prev.getResponseDataAsString());
	f.close();





	String responseType =&quot;JSON&quot;; 
	JSONArray fetexpectedResponseCodeFromArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
	int fetexpectedResponseCodeFromArraySize=fetexpectedResponseCodeFromArray.length();
	int checkExpectedResponseCode = Integer.valueOf(vars.get(&quot;testScenarioNumber&quot;));
		for(int i=0;i&lt;fetexpectedResponseCodeFromArraySize;i++)
			{
				JSONObject newJSonObject = new JSONObject();		
				newJSonObject = fetexpectedResponseCodeFromArray.getJSONObject((checkExpectedResponseCode-1));
				expectedResponseCode=newJSonObject.getInt(&quot;expectedResponseCode&quot;);	
			}

					//JSONObject newExpectedResults after trimming the expected response code
					if (String.valueOf(expectedResponseCode).equals(prev.getResponseCode())) 
					
					{
						responseCodeValidation = &quot;PASS&quot;;
						vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
										log.info(responsecode);
										//Get actual table result
										 responseMsg = prev.getResponseDataAsString();
										responseMsg=responseMsg.replace(&quot;actualDBResult&quot;,&quot;&quot;);
										
										//Object checkResponse = responseMsg;
										if(responseCodeValidation.equalsIgnoreCase(&quot;PASS&quot;))
										{
										
											JSONArray newactualDBResult = new JSONArray(responseMsg);
											log.info(&quot;responseMsg--&gt;&quot;+String.valueOf(newactualDBResult));
											
											//Get expected table result
											String newexpectedDBResultString = vars.get(&quot;expectedTableValue&quot;);
											JSONArray newexpectedDBResult = new JSONArray(newexpectedDBResultString);
											
																 	JSONArray newJSONArray = new JSONArray();
																	newJSONArray.put(newactualDBResult);
																	newJSONArray.put(newexpectedDBResult);
																		
																	JSONArray ignoreKeysArray = new JSONArray();
																	newJSONArray.put(ignoreKeysArray);
																	log.info(&quot;Array----&gt;&quot;+String.valueOf(newJSONArray));
											
												 jsoncompareResult =String.valueOf(jComparator.areEqual(newJSONArray));
																 	//String.valueOf(jComparator.areEqual(responseMsg1,responseMsg2));
																 	log.info(&quot;Result-----&gt;&quot;+jsoncompareResult);
																 	if(jsoncompareResult.equalsIgnoreCase(&quot;True&quot;)){
																		vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
																		} else
																		{
																		vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;);
																		log.info(&quot;-----------------&gt;FALSE&quot;);
																					jsoncompareResult=&quot;FALSE&quot;;	
																					vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
																					String jsonCompareFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(&quot;apiActualExpectedFileName&quot;).concat(vars.get(&quot;quaryNameExpected&quot;)).concat(&quot;.txt&quot;);
																					log.info(&quot;jsonCompareFileName----------------&gt;&quot;+jsonCompareFileName);
																			 		f = new FileOutputStream(jsonCompareFileName,true);
																					p = new PrintStream(f); 
																					this.interpreter.setOut(p);
																					print(&quot;Actual Table Result: ------&gt;&quot;+responseMsg);
																					print(&quot;\nExpected Table Result:-----&gt;&quot;+vars.get(&quot;expectedTableValue&quot;));
																					f.close();
																			 		 reasonForFailure=&quot;Expected table result not match with actual table result:  &quot;;
																			 		 reasonForFailure=reasonForFailure.concat(jsonCompareFileName);		
																		}
																 	
																			}
																			
															}
				
					else {
							 reasonForFailure=&quot;Actual response code received is &quot;;
							 reasonForFailure=reasonForFailure.concat(String.valueOf(prev.getResponseCode()));			 
							 vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
							 log.info(reasonForFailure);
							 //testResult=&quot;FAIL&quot;;
						}	


String actualResponseCode=&quot;NA&quot;;
		actualResponseCode =prev.getResponseCode();	 	


		log.info(jsonResultsFileName);
		log.info(vars.get(&quot;responseCodeValidation&quot;));
		log.info(String.valueOf(expectedResponseCode));
		log.info(actualResponseCode);
		log.info(vars.get(&quot;overallInputFile&quot;));
		
		
		//Store Results in a csv file
		String resultToBeStored =vars.get(&quot;payloadInjectionDate&quot;).concat(&quot;,&quot;).concat(vars.get(&quot;payloadInjectionTime&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;moduleName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;payloadFilePath&quot;)).concat(&quot;,&quot;).concat(jsonResultsFileName).concat(&quot;,&quot;).concat(vars.get(&quot;responseCodeValidation&quot;)).concat(&quot;,&quot;).concat(String.valueOf(expectedResponseCode)).concat(&quot;,&quot;).concat(actualResponseCode).concat(&quot;,&quot;).concat(vars.get(&quot;overallInputFile&quot;)).concat(&quot;,&quot;).concat(&quot;Select Query&quot;).concat(&quot;,&quot;).concat(&quot;mysqlQuery&quot;).concat(&quot;,&quot;).concat(reasonForFailure).concat(&quot;,&quot;).concat(vars.get(&quot;consentPerson&quot;));



		
	////	if (debug)log.info(&quot;*****&quot;+resultToBeStored);
		f = new FileOutputStream(vars.get(&quot;apiResultsFileName&quot;),true);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		print(resultToBeStored);
		f.close();




}
catch(Exception e){log.info(e);}
</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                        <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="true">
                          <stringProp name="ConstantTimer.delay">${firstValidationvalue}</stringProp>
                        </ConstantTimer>
                        <hashTree/>
                      </hashTree>
                    </hashTree>
                  </hashTree>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="API Validation Thread Group_B" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.duration">32400</stringProp>
        <stringProp name="ThreadGroup.delay">1200</stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </ThreadGroup>
      <hashTree>
        <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Set-up results file and directories before starting the test" enabled="true">
          <boolProp name="WAITING">true</boolProp>
          <boolProp name="SUCCESFULL">true</boolProp>
          <stringProp name="RESPONSE_CODE">200</stringProp>
          <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
          <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
          <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
          <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
          <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
          <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
          <stringProp name="URL"></stringProp>
          <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
        </kg.apc.jmeter.samplers.DummySampler>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create a timestamped folder name" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Create a timestamped folder
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create a timestamped folder name - Beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String testStartDate = dateFormatter.format(cal.getTime());
	String testStartTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;timeStampedFolderName&quot;,testStartDate.concat(&quot;_&quot;).concat(testStartTime));
	if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
	   // includes: Windows 2000,  Windows 95, Windows 98, Windows NT, Windows Vista, Windows XP
	   vars.put(&quot;operatingSystem&quot;,&quot;Windows&quot;);
	} else {
	   // everything else
	   vars.put(&quot;operatingSystem&quot;,&quot;Unix&quot;);
	}
	if (debug) log.info(&quot;Create a timestamped folder name - Beanshell ends&quot;);
} catch (Exception e) {
	System.out.println(&quot;Something terribly wrong with this test set-up? &quot;+ e.toString());
}
</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create all project directories as required" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Create all project directories
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create all project directories as required - beanshell starts&quot;);
	
	File errorsDirectory = new File(vars.get(&quot;errorsPath&quot;));
	if(!errorsDirectory.exists()){
	     errorsDirectory.mkdir();
	}
	
	String timeStampedErrorsPath = vars.get(&quot;errorsPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedErrorsDirectory = new File(timeStampedErrorsPath);
	if(!timeStampedErrorsDirectory.exists()){
	     timeStampedErrorsDirectory.mkdir();
	}
	vars.put(&quot;timeStampedErorsPath&quot;,timeStampedErrorsPath);
	if (debug) log.info(&quot;Create all project directories as required - beanshell ends&quot;);
	String errorsFileName = timeStampedErrorsPath.concat(&quot;errors_&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;).concat(&quot;.txt&quot;));
	vars.put(&quot;errorsFileName&quot;,errorsFileName);
	f = new FileOutputStream(errorsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error File Created&quot;);
	f.close();
	File jsonWorkbenchDirectory = new File(vars.get(&quot;jsonWorkbenchPath&quot;));
	if(!jsonWorkbenchDirectory.exists()){
	     jsonWorkbenchDirectory.mkdir();
	}
	String timeStampedJSONWorkbenchPath = vars.get(&quot;jsonWorkbenchPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJSONWorkbenchDirectory = new File(timeStampedJSONWorkbenchPath);
	if(!timeStampedJSONWorkbenchDirectory.exists()){
	     timeStampedJSONWorkbenchDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJSONWorkbenchPath&quot;,timeStampedJSONWorkbenchPath);
	File jsonWorkbenchResultsValidationDirectory = new File(vars.get(&quot;jsonWorkbenchResultsValidationPath&quot;));
	if(!jsonWorkbenchResultsValidationDirectory.exists()){
	     jsonWorkbenchResultsValidationDirectory.mkdir();
	}
	String timeStampedJSONWorkbenchResultsValidationPath = vars.get(&quot;jsonWorkbenchResultsValidationPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJsonWorkbenchResultsValidationDirectory = new File(timeStampedJSONWorkbenchResultsValidationPath);
	if(!timeStampedJsonWorkbenchResultsValidationDirectory.exists()){
	     timeStampedJsonWorkbenchResultsValidationDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;,timeStampedJSONWorkbenchResultsValidationPath);
	
	File jsonPayloadDirectory = new File(vars.get(&quot;jsonPayloadPath&quot;));
	if(!jsonPayloadDirectory.exists()){
	     jsonPayloadDirectory.mkdir();
	}
	
	String timeStampedJsonPayloadPath = vars.get(&quot;jsonPayloadPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJsonPayloadDirectory = new File(timeStampedJsonPayloadPath);
	if(!timeStampedJsonPayloadDirectory.exists()){
	     timeStampedJsonPayloadDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJsonPayloadPath&quot;,timeStampedJsonPayloadPath);
	
	File resultsDirectory = new File(vars.get(&quot;resultsPath&quot;));
	if(!resultsDirectory.exists()){
	     resultsDirectory.mkdir();
	}
	
	String timeStampledResultsPath = vars.get(&quot;resultsPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampledResultsDirectory = new File(timeStampledResultsPath);
	if(!timeStampledResultsDirectory.exists()){
	     timeStampledResultsDirectory.mkdir();
	}
	vars.put(&quot;timeStampledResultsPath&quot;,timeStampledResultsPath);
	JMeterUtils.setProperty(&quot;timeStampledResultsPath&quot;,timeStampledResultsPath);
	
	File jsonOutputDirectory = new File(vars.get(&quot;jsonOutputPath&quot;));
	if(!jsonOutputDirectory.exists()){
	     jsonOutputDirectory.mkdir();
	}
	
	String timeStampedJsonOutputPath = vars.get(&quot;jsonOutputPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedJsonOutputDirectory = new File(timeStampedJsonOutputPath);
	if(!timeStampedJsonOutputDirectory.exists()){
	     timeStampedJsonOutputDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJsonOutputPath&quot;,timeStampedJsonOutputPath);
	
	//jsonWorkbenchURLParametersPath
	File jsonWorkbenchURLParametersDirectory = new File(vars.get(&quot;jsonWorkbenchURLParametersPath&quot;));
	if(!jsonWorkbenchURLParametersDirectory.exists()){
	     jsonWorkbenchURLParametersDirectory.mkdir();
	}

	String timeStampedJsonWorkbenchURLParametersPath = vars.get(&quot;jsonWorkbenchURLParametersPath&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(vars.get(&quot;pathSeparator&quot;));
	File timeStampedjJsonWorkbenchURLParametersDirectory = new File(timeStampedJsonWorkbenchURLParametersPath);
	if(!timeStampedjJsonWorkbenchURLParametersDirectory.exists()){
	     timeStampedjJsonWorkbenchURLParametersDirectory.mkdir();
	}
	vars.put(&quot;timeStampedJsonWorkbenchURLParametersPath&quot;,timeStampedJsonWorkbenchURLParametersPath);
	

	
} catch (Exception e) {
	String errorCode = &quot;1100&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
} </stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create a file to Store the overall results" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Create a file to Store the API validation results
//Modified in N12 version
import org.apache.jmeter.util.JMeterUtils;

try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create a file to Store the Overall API validation results - beanshell starts&quot;);
	
	String apiResultsFileName = vars.get(&quot;timeStampledResultsPath&quot;).concat(&quot;overall_results.csv&quot;);
	f = new FileOutputStream(apiResultsFileName,false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	//print(&quot;Test Execution Date,Execution Time,API Name,API Payload Input file,Test Result&quot;);
	print(&quot;#,Payload Injection Date,Payload Injection Time,API Name,Module Name,Total TCs,Pass Count,Fail Count,Owner&quot;);
	f.close();
	vars.put(&quot;overallResultsFileName&quot;,apiResultsFileName);
	JMeterUtils.setProperty(&quot;overallResultsFileName&quot;,apiResultsFileName);
	if (debug) log.info(&quot;Create a file to Store the Overall API validation results - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1401&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
}</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="selectedFieldsJson File" enabled="true">
          <boolProp name="WAITING">true</boolProp>
          <boolProp name="SUCCESFULL">true</boolProp>
          <stringProp name="RESPONSE_CODE">200</stringProp>
          <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
          <stringProp name="REQUEST_DATA"></stringProp>
          <stringProp name="RESPONSE_DATA">${__FileToString(${fileFromJSON},,)}</stringProp>
          <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
          <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
          <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
          <stringProp name="URL"></stringProp>
          <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
        </kg.apc.jmeter.samplers.DummySampler>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">//Read Selected Fields Json File
import org.json.JSONArray;
import org.json.JSONObject;

String selectedFieldsJson = prev.getResponseDataAsString(); 
JSONArray selectedFieldsJsonArray = new JSONArray(selectedFieldsJson);
//log.info(String.valueOf(selectedFieldsJsonArray));
vars.put(&quot;selectedFieldsJsonArray&quot;,String.valueOf(selectedFieldsJsonArray));


</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <WhileController guiclass="WhileControllerGui" testclass="WhileController" testname="While there are APIs to be validated" enabled="true">
          <stringProp name="TestPlan.comments">		</stringProp>
          <stringProp name="WhileController.condition">true</stringProp>
        </WhileController>
        <hashTree>
          <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="Counter" enabled="true">
            <stringProp name="CounterConfig.start">1</stringProp>
            <stringProp name="CounterConfig.end"></stringProp>
            <stringProp name="CounterConfig.incr">1</stringProp>
            <stringProp name="CounterConfig.name">counterValue</stringProp>
            <stringProp name="CounterConfig.format"></stringProp>
            <boolProp name="CounterConfig.per_user">false</boolProp>
          </CounterConfig>
          <hashTree/>
          <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="true">
            <stringProp name="filename">${apisToBeValidatedPath}APIsToBeValidated_B.csv</stringProp>
            <stringProp name="fileEncoding"></stringProp>
            <stringProp name="variableNames">slNo,apiName,apiMethod,apiPath,apiInputsFile,toBeValidated,moduleName,fileType,payloadJSON,expectedJSON,consentPerson,scenario,mysql</stringProp>
            <boolProp name="ignoreFirstLine">true</boolProp>
            <stringProp name="delimiter">,</stringProp>
            <boolProp name="quotedData">false</boolProp>
            <boolProp name="recycle">false</boolProp>
            <boolProp name="stopThread">true</boolProp>
            <stringProp name="shareMode">shareMode.all</stringProp>
          </CSVDataSet>
          <hashTree/>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="Should this API Be Validated" enabled="true">
            <stringProp name="IfController.condition">&quot;${toBeValidated}&quot;==&quot;y&quot;</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
          </IfController>
          <hashTree>
            <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Check input file is available?" enabled="true">
              <boolProp name="WAITING">true</boolProp>
              <boolProp name="SUCCESFULL">true</boolProp>
              <stringProp name="RESPONSE_CODE">200</stringProp>
              <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
              <stringProp name="REQUEST_DATA">${apiInputsPath}${apiInputsFile}</stringProp>
              <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
              <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
              <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
              <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
              <stringProp name="URL"></stringProp>
              <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
            </kg.apc.jmeter.samplers.DummySampler>
            <hashTree>
              <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">String filePath=vars.get(&quot;apiInputsPath&quot;);
String fileName = vars.get(&quot;apiInputsFile&quot;);
String apiName = vars.get(&quot;apiName&quot;);
String filePathString=filePath.concat(fileName);
File f = new File(filePathString);
if(f.exists() &amp;&amp; !f.isDirectory()) { 
   vars.put(&quot;fileCheck&quot;,&quot;y&quot;);
}
else
{
log.info(filePathString+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
 vars.put(&quot;fileCheck&quot;,&quot;n&quot;);
 System.out.println(filePathString+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
}
</stringProp>
              </BeanShellPreProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
              <stringProp name="IfController.condition">&quot;${fileCheck}&quot;==&quot;y&quot;</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
            </IfController>
            <hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Calculate number of fields in CSV for input and expected results" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="REVISE - Calculate number of fields in CSV for input and expected results" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//Calculate the number of fields in CSV for input
//try {
	Boolean debug;

	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Calculate number of fields in CSV for input and expected results - beanshell starts&quot;);
	String strCurrentLine;
	String overallInputFile = vars.get(&quot;apiInputsPath&quot;).concat(vars.get(&quot;apiInputsFile&quot;));
	if (debug) log.info(&quot;Overall Input File: &quot;+overallInputFile);
	vars.put(&quot;overallInputFile&quot;,overallInputFile);
	BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	StringBuilder sbInputScenarios;
	StringBuilder sbExpectedResults;
	String[] splitLine;
	if ((strCurrentLine = br.readLine()) != null) {
		splitLine = strCurrentLine.split(&quot;,&quot;);
	}
	//log.info(&quot;Split line length: &quot;+String.valueOf(splitLine.length));
	//start Field for input Payload
	//end Field for input JSON
	//startField for expected results JSON
	//end field for expected results JSON
	int startFieldForExpectedResults = 0;
	int urlInputField = Integer.parseInt(vars.get(&quot;urlInputField&quot;));
	Boolean expectedResponseCodeFound= false;
	String inputPayloadExistence = &quot;yes&quot;;
	for (int i=0;i&lt;splitLine.length;i++) {
		log.info(String.valueOf(i)+&quot;:&quot;+splitLine[i]);
		if (splitLine[i].equals(&quot;expectedResponseCode&quot;)) {
			break;
		} else {
			startFieldForExpectedResults++;
		}
	}
	
	if (debug) log.info(&quot;URLInput Starting and ending field: &quot;+vars.get(&quot;urlInputField&quot;));
	if (debug) log.info(&quot;Expected Results Starting Field: &quot;+String.valueOf(startFieldForExpectedResults));
	if ((startFieldForExpectedResults-urlInputField)==1) inputPayloadExistence = &quot;no&quot;;
	vars.put(&quot;startFieldForExpectedResults&quot;,String.valueOf(startFieldForExpectedResults));
	vars.put(&quot;totalNumberOfFields&quot;,String.valueOf(splitLine.length));
	vars.put(&quot;inputPayloadExistence&quot;,inputPayloadExistence);
	long millis = System.currentTimeMillis();
	vars.put(&quot;millis&quot;,String.valueOf(millis));

	
	/*
	int numberOfFields =0;
	int urlInputField = Integer.parseInt(vars.get(&quot;urlInputField&quot;));

	for (int i=0;i&lt;splitLine.length;i++) {
		log.info(splitLine[i]);
	}
	vars.put(&quot;inputFileStartingField&quot;,String.valueOf(urlInputField+1));
	for (int i=(urlInputField+1);i&lt;splitLine.length;i++) {
		if (splitLine[i].equals(&quot;expectedResponseCode&quot;)) {
			break;
			log.info(&quot;found expResCod&quot;);
		} else {
			numberOfFields++;
			log.info(&quot;incrementing no of fields&quot;);
		}
	}
	if (debug) log.info(&quot;Number of Fields: &quot;+String.valueOf(numberOfFields+urlInputField+1));
	vars.put(&quot;numberOfFields&quot;,String.valueOf(numberOfFields+urlInputField+1));
	vars.put(&quot;startCountForExpectedResults&quot;,String.valueOf(numberOfFields+urlInputField+2));
	vars.put(&quot;endCountForExpectedResults&quot;,String.valueOf(splitLine.length));
	//Current time in millis
	long millis = System.currentTimeMillis();
	vars.put(&quot;millis&quot;,String.valueOf(millis));
	if (debug) log.info(&quot;Calculate number of fields in CSV for input and expected results - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1200&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
	
}*/</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Split files and create exclusive files for URL Parameters, input fields &amp; expected results" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="REVISE - Split input file and store file names" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//Store input fields and expected results file names with full path
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Split input file and store file names - beanshell starts&quot;);
	String inputFile =null;
	inputFile=vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;inputFields&quot;).concat(vars.get(&quot;millis&quot;)).concat(vars.get(&quot;counterValue&quot;)).concat(&quot;.csv&quot;);
	if (debug) log.info(&quot;input file: &quot;+inputFile);	
	String expectedResultsFile =null;	
	expectedResultsFile= vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;expectedResults&quot;).concat(vars.get(&quot;millis&quot;)).concat(vars.get(&quot;counterValue&quot;)).concat(&quot;.csv&quot;);
	String urlInputFieldFile =null;
	urlInputFieldFile=vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;urlInputField&quot;).concat(vars.get(&quot;millis&quot;)).concat(vars.get(&quot;counterValue&quot;)).concat(&quot;.csv&quot;);
	if (debug) log.info(&quot;Expected results file: &quot;+expectedResultsFile);
	vars.put(&quot;inputFile&quot;,inputFile);
	vars.put(&quot;expectedResultsFile&quot;,expectedResultsFile);
	vars.put(&quot;urlInputFieldFile&quot;,urlInputFieldFile);
//vars.put(&quot;startFieldForExpectedResults&quot;,String.valueOf(startFieldForExpectedResults));
//	vars.put(&quot;totalNumberOfFields&quot;,String.valueOf(splitLine.length));
//	vars.put(&quot;inputPayloadExistence&quot;,inputPayloadExistence);
	int urlInputField = Integer.parseInt(vars.get(&quot;urlInputField&quot;));
	int totalNumberOfFields = Integer.parseInt(vars.get(&quot;totalNumberOfFields&quot;));
	log.info(&quot;totalNumberOfFields&quot;+vars.get(&quot;totalNumberOfFields&quot;));
	String inputPayloadExistence = vars.get(&quot;inputPayloadExistence&quot;);
	int startFieldForExpectedResults = Integer.parseInt(vars.get(&quot;startFieldForExpectedResults&quot;));
	
	String strCurrentLine;
	String overallInputFile = vars.get(&quot;apiInputsPath&quot;).concat(vars.get(&quot;apiInputsFile&quot;));
	if (debug) log.info(&quot;Overall Inputs File: &quot;+overallInputFile);
	
	//Perform Split - create URLInputField File
	BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	String line;
	String[] inputSplitLine;
	f = new FileOutputStream(urlInputFieldFile, false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	String csvLine=&quot;&quot;;
	while ((line=br.readLine())!=null) {
		inputSplitLine = line.split(&quot;,&quot;);
		csvLine = inputSplitLine[urlInputField];
		print(csvLine);
	}
	f.close();
	br.close();
log.info(&quot;13001&quot;);

	//Perform Split - Create input File
	
	if (inputPayloadExistence.equals(&quot;yes&quot;)) {
		BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
		String line;
		String[] inputSplitLine;
		f = new FileOutputStream(inputFile, false);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		while ((line=br.readLine())!=null) {
			inputSplitLine = line.split(&quot;,&quot;);
			String csvLine=&quot;&quot;;
			for (int i=(urlInputField+1);i&lt;=(startFieldForExpectedResults-1);i++) {
				if (i==(startFieldForExpectedResults-1)) {
					csvLine = csvLine.concat(inputSplitLine[i]);
				} else {
					csvLine = csvLine.concat(inputSplitLine[i]).concat(&quot;,&quot;);
				}
			}
			print(csvLine);
		}
	}
	f.close();
	br.close();
	log.info(&quot;13002&quot;);

	//Perform Split - Create expected results File
	BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	String line;
	String[] expectedResultSplitLine;
	f = new FileOutputStream(expectedResultsFile, false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	while ((line=br.readLine())!=null) {
		expectedResultSplitLine = line.split(&quot;,&quot;);
		String csvLine=&quot;&quot;;
		for (int i=startFieldForExpectedResults;i &lt; totalNumberOfFields;i++) {
			if (i==(expectedResultSplitLine.length-1)) {
				csvLine = csvLine.concat(expectedResultSplitLine[i]);
			} else {
				csvLine = csvLine.concat(expectedResultSplitLine[i]).concat(&quot;,&quot;);
			}
		}
		if (csvLine.length()&gt;0) {
			print(csvLine);
		}
	}
	f.close();
	br.close();
log.info(&quot;13003&quot;);
	
	//Find the number of columns
	/*BufferedReader br = new BufferedReader(new FileReader(overallInputFile));     
	StringBuilder sbInputScenarios;
	StringBuilder sbExpectedResults;
	String[] splitLine;
	if ((strCurrentLine = br.readLine()) != null) {
		splitLine = strCurrentLine.split(&quot;,&quot;);
	}

	int inputFileStartingField = Integer.parseInt(vars.get(&quot;inputFileStartingField&quot;))-1;
	for (int i=inputFileStartingField;i&lt;splitLine.length;i++) {
		if (splitLine[i].equals(&quot;expectedResponseCode&quot;)) {
			break;
		} else {
			numberOfFields++;
		}
	}
	br.close();
	numberOfFields = inputFileStartingField+numberOfFields;
	*/
	
	
	if (debug) log.info(&quot;Split input file and store file names - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1300&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Create a file to Store the API validation results" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//Create a file to Store the API/SQL validation results
try {

	String validationType = vars.get(&quot;mysql&quot;);
	
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Create a file to Store the API validation results - beanshell starts&quot;);
	
	String apiResultsFileName = vars.get(&quot;timeStampledResultsPath&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;_&quot;).concat(vars.get(&quot;timeStampedFolderName&quot;)).concat(&quot;_results.csv&quot;);
	f = new FileOutputStream(apiResultsFileName,false);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	if(validationType.equalsIgnoreCase(&quot;y&quot;))
	{
	print(&quot;Test Execution Date,Execution Time,SQL Query Name,Module Name,Test Scenario Number,Mysql Query,Actual Table Result,Test Result,Expected Response Code,Actual Response Code,Query Inputs File,Query Type ,My SQL Query,Reason For Failure,Owner&quot;);
	}else
	{
	print(&quot;Test Execution Date,Execution Time,API Name,Module Name,Test Scenario Number,JSON Payload,Results JSON File Name,Test Result,Expected Response Code,Actual Response Code,API Inputs File,API Method,API Path &amp; Value,Reason For Failure,Owner&quot;);
	}
	f.close();
	vars.put(&quot;apiResultsFileName&quot;,apiResultsFileName);
	
	if (debug) log.info(&quot;Create a file to Store the API validation results - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1400&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString());
	f.close();
}</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Condition the input and expected results file before converting CSV to JSON" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Condition the input and expected results file before converting CSV to JSON" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//condition the input file

import java.io.File;
import java.io.IOException;
import java.lang.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Condition the input and expected results file before converting CSV to JSON - beanshell starts&quot;);
	String existingInputFileName = vars.get(&quot;inputFile&quot;);
	String existingExpectedResultsFileName = vars.get(&quot;expectedResultsFile&quot;);
	String newInputFileName = vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;tempInput.csv&quot;);
	String newExpectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchPath&quot;).concat(&quot;tempExpectedResults.csv&quot;);
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
		f1 = new FileOutputStream(newInputFileName, false);
		p1 = new PrintStream(f1); 
		this.interpreter.setOut(p1); 
		String line;
		Boolean lineChanged =false;
		BufferedReader brTest = new BufferedReader(new FileReader(existingInputFileName));
		while ((line = brTest.readLine()) != null) {
			if (!lineChanged) {
				print(line.replace(&quot;.&quot;, &quot;/&quot;));
				lineChanged = true;
			} else {
				print(line);
			}
		}
		brTest.close();
		f1.close();
	}
	f1 = new FileOutputStream(newExpectedResultsFileName, false);
	p1 = new PrintStream(f1); 
	this.interpreter.setOut(p1); 
	String line;
	Boolean lineChanged =false;
	BufferedReader brTest = new BufferedReader(new FileReader(existingExpectedResultsFileName));
	while ((line = brTest.readLine()) != null) {
		if (!lineChanged) {
			print(line.replace(&quot;.&quot;, &quot;/&quot;));
			lineChanged = true;
		} else {
			print(line);
		}
	}
	brTest.close();
	f1.close();
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) new File(existingInputFileName).delete();
	new File(existingExpectedResultsFileName).delete();
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) new File(newInputFileName).renameTo(new File(existingInputFileName));
	new File(newExpectedResultsFileName).renameTo(new File(existingExpectedResultsFileName));
	if (debug) log.info(&quot;Condition the input and expected results file before converting CSV to JSON - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1700&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
              </hashTree>
              <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler- URL Parameters" enabled="true">
                <stringProp name="BeanShellSampler.query">import org.json.JSONArray;
import org.json.JSONObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
// 
try {
//log.info(&quot;I am inside CSV to JSON Converter&quot;);
String headerLine;

BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;urlInputFieldFile&quot;)));
		if ((line = brTest.readLine()) != null) {
			headerLine = line;//.replace(&quot;/&quot;,&quot;.&quot;);
		}
brTest.close();


//log.info(&quot;Header Line...&quot;+headerLine);
String[] headerLineSplit = headerLine.split(&quot;,&quot;);
String regex=&quot;/\\d+/&quot;;
for (int i=0;i&lt;headerLineSplit.length;i++) {
	Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
	Matcher matcher = pattern.matcher(headerLineSplit[i]);
	if (matcher.find()) {
		//log.info(&quot;found&quot;);
		String stringToBeReplaced = matcher.group(0).substring(0,(matcher.group(0).length()-1));
		String replacementString = stringToBeReplaced.replace(&quot;/&quot;,&quot;[&quot;);
		replacementString= replacementString.concat(&quot;]&quot;);
		//log.info(&quot;stringToBeReplaced...&quot;+stringToBeReplaced);
		//log.info(&quot;replacementString...&quot;+replacementString);
		headerLineSplit[i]=headerLineSplit[i].replace(stringToBeReplaced,replacementString);
		//log.info(&quot;headerLineSplit[i] after replacement: &quot;+headerLineSplit[i]);
		//headerLineSplit[i]=headerLineSplit[i].replaceAll(&quot;
	}
	headerLineSplit[i]=headerLineSplit[i].replace(&quot;/&quot;,&quot;.&quot;);
	
}

JSONArray inputFieldsJSONArray = new JSONArray();
JSONObject testDataJSONObject;
int count=0;
BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;urlInputFieldFile&quot;)));
while (((line = brTest.readLine()) != null)) {
	if (count&gt;0) {
		String[] testDataSplit = line.split(&quot;,&quot;);
		testDataJSONObject = new JSONObject();
		//log.info(&quot;Header row length :&quot;+String.valueOf(headerLineSplit.length));
		//log.info(&quot;Test Data length :&quot;+String.valueOf(testDataSplit.length));
		for (int i=0;i&lt;headerLineSplit.length;i++) {
			//log.info(String.valueOf(i));
			//log.info(headerLineSplit[i]);
			//log.info(testDataSplit[i]);
			//log.info(headerLineSplit[i]);
			if (i&lt;testDataSplit.length){
				//log.info(&quot;data avl&quot;);
				if (testDataSplit[i].length()==0 || testDataSplit[i].equals(&quot;null&quot;))
					testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
				else {
					if (testDataSplit[i].equalsIgnoreCase(&quot;true&quot;) || testDataSplit[i].equalsIgnoreCase(&quot;false&quot;)) {
						Boolean convertedValue = Boolean.parseBoolean(testDataSplit[i]);
						testDataJSONObject.put(headerLineSplit[i],convertedValue);	
					} else {
						try {
							Integer convertedValue = Integer.parseInt(testDataSplit[i]);
							testDataJSONObject.put(headerLineSplit[i],convertedValue);	
						} catch (Exception e) {
							try {
								Double convertedValue = Double.parseDouble(testDataSplit[i]);
								testDataJSONObject.put(headerLineSplit[i],convertedValue);	
							} catch (Exception e) {
								testDataJSONObject.put(headerLineSplit[i],testDataSplit[i]);	
							}
						}
					}
					
				}
			}else{ 
				//log.info(&quot;data not avl&quot;);

				testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
			}
			//log.info(String.valueOf(i)+&quot; - &quot;+testDataJSONObject.toString());
		}
		//log.info(&quot;outside for&quot;);
		String nestedJSON = JsonUnflattener.unflatten(testDataJSONObject.toString());
		try{
		inputFieldsJSONArray.put(new JSONObject(nestedJSON));
		} catch(Exception e){
			log.info(e.toString());
		}
		//log.info(&quot;added to json array&quot;);
	}
	count++;
}
vars.put(&quot;urlInputFieldArray&quot;,inputFieldsJSONArray.toString());
int urlInputFieldArraysize =inputFieldsJSONArray.length();
log.info(&quot;Final url parameters array: &quot;+inputFieldsJSONArray.toString());
log.info(&quot;urlInputFieldArraysize : &quot;+String.valueOf(urlInputFieldArraysize));
vars.put(&quot;jsonLoop&quot;,String.valueOf(urlInputFieldArraysize));
} catch (Exception e) {
	String errorCode=&quot;1710&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}

/*
Boolean debug;
if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
if (debug) log.info(&quot;entering into Dynamic Post Data Processor&quot;);
JSONObject payloadObject = new JSONObject(vars.get(&quot;payload&quot;));
String flattenedJSON = JsonFlattener.flatten(payloadObject.toString());
if (debug) log.info(&quot;Flattened result...:&quot;+flattenedJSON);
nestedJSON = JsonUnflattener.unflatten(flattenedJSONPayload.toString());
*/


/*
try {
	var pkg = JavaImporter(org.openqa.selenium)
	var support_ui = JavaImporter(org.openqa.selenium.support.ui.WebDriverWait)
	var wait = new support_ui.WebDriverWait(WDS.browser, 10000)
	WDS.sampleResult.sampleStart()
	WDS.sampleResult.getLatency()
	WDS.browser.get(WDS.props.get(&quot;csvJSONConversionUtility&quot;))
	var fileUploadTab = WDS.browser.findElement(pkg.By.linkText(&quot;Choose File&quot;))
	fileUploadTab.click()
	var fileUploadButton = WDS.browser.findElement(pkg.By.id(&apos;f1&apos;))
	fileUploadButton.click()
	fileUploadButton.sendKeys(WDS.vars.get(&quot;inputFile&quot;))
	var screenshot1 = WDS.browser.getScreenshotAs(pkg.OutputType.FILE)
	screenshot1.renameTo(new java.io.File(&apos;screenshot1.png&apos;))
	screenshot1 = WDS.browser.getScreenshotAs(pkg.OutputType.FILE)
	screenshot1.renameTo(new java.io.File(&apos;screenshot1.png&apos;))
	var inputFileArray = WDS.browser.findElement(pkg.By.id(&apos;txta&apos;)).getAttribute(&apos;value&apos;)
	WDS.vars.put(&quot;inputFieldsJsonArray&quot;,inputFileArray)
	//WDS.log.info(inputFileArray)
	//WDS.browser.close();
} catch (err) {
   throw err
}*/</stringProp>
                <stringProp name="BeanShellSampler.filename"></stringProp>
                <stringProp name="BeanShellSampler.parameters"></stringProp>
                <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
              </BeanShellSampler>
              <hashTree/>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If input payload is applicable" enabled="true">
                <stringProp name="IfController.condition">&quot;${inputPayloadExistence}&quot;==&quot;yes&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler- Input Parameters" enabled="true">
                  <stringProp name="BeanShellSampler.query">//CSV TO JSON Converter
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
import java.util.regex.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;

// 

//log.info(&quot;I am inside CSV to JSON Converter&quot;);
String headerLine;

BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;inputFile&quot;)));
		if ((line = brTest.readLine()) != null) {
			headerLine = line;//.replace(&quot;/&quot;,&quot;.&quot;);
		}
brTest.close();


//log.info(&quot;Header Line...&quot;+headerLine);
String[] headerLineSplit = headerLine.split(&quot;,&quot;);
String regex=&quot;/\\d+/&quot;;
for (int i=0;i&lt;headerLineSplit.length;i++) {
	Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
	Matcher matcher = pattern.matcher(headerLineSplit[i]);
	if (matcher.find()) {
		//log.info(&quot;found&quot;);
		String stringToBeReplaced = matcher.group(0).substring(0,(matcher.group(0).length()-1));
		String replacementString = stringToBeReplaced.replace(&quot;/&quot;,&quot;[&quot;);
		replacementString= replacementString.concat(&quot;]&quot;);
		//log.info(&quot;stringToBeReplaced...&quot;+stringToBeReplaced);
		//log.info(&quot;replacementString...&quot;+replacementString);
		headerLineSplit[i]=headerLineSplit[i].replace(stringToBeReplaced,replacementString);
		//log.info(&quot;headerLineSplit[i] after replacement: &quot;+headerLineSplit[i]);
		//headerLineSplit[i]=headerLineSplit[i].replaceAll(&quot;
	}
	headerLineSplit[i]=headerLineSplit[i].replace(&quot;/&quot;,&quot;.&quot;);
	
}

JSONArray inputFieldsJSONArray = new JSONArray();
JSONObject testDataJSONObject;
int count=0;
BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;inputFile&quot;)));
while (((line = brTest.readLine()) != null)) {
	if (count&gt;0) {
		String[] testDataSplit = line.split(&quot;,&quot;);
		testDataJSONObject = new JSONObject();
		//log.info(&quot;Header row length :&quot;+String.valueOf(headerLineSplit.length));
		//log.info(&quot;Test Data length :&quot;+String.valueOf(testDataSplit.length));
		for (int i=0;i&lt;headerLineSplit.length;i++) {
			//log.info(String.valueOf(i));
			//log.info(headerLineSplit[i]);
			//log.info(testDataSplit[i]);
			//log.info(headerLineSplit[i]);
			if (i&lt;testDataSplit.length){
				if (!testDataSplit[i].equals(&quot;IGNORE&quot;)) {
				//log.info(&quot;data avl&quot;);
					if (testDataSplit[i].length()==0 || testDataSplit[i].equals(&quot;null&quot;))
						testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
					else {
						if (testDataSplit[i].equalsIgnoreCase(&quot;true&quot;) || testDataSplit[i].equalsIgnoreCase(&quot;false&quot;)) {
							Boolean convertedValue = Boolean.parseBoolean(testDataSplit[i]);
							testDataJSONObject.put(headerLineSplit[i],convertedValue);	
						} else {
							try {
								JSONArray convertedValue = new JSONArray(testDataSplit[i]);
								testDataJSONObject.put(headerLineSplit[i],convertedValue);	
							} catch (Exception e) {
								try {
									JSONObject convertedValue = new JSONObject(testDataSplit[i]);
									testDataJSONObject.put(headerLineSplit[i],convertedValue);
								} catch (Exception e) {
									try {
										Integer convertedValue = Integer.parseInt(testDataSplit[i]);
										testDataJSONObject.put(headerLineSplit[i],convertedValue);	
									} catch (Exception e) {
										try {
											Double convertedValue = Double.parseDouble(testDataSplit[i]);
											testDataJSONObject.put(headerLineSplit[i],convertedValue);	
										} catch (Exception e) {
											testDataJSONObject.put(headerLineSplit[i],testDataSplit[i]);	
										}
									}
								}
							}
						}	
					}
				}
			}else{ 
				//log.info(&quot;data not avl&quot;);

				testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
			}
			//log.info(String.valueOf(i)+&quot; - &quot;+testDataJSONObject.toString());
		}
		//log.info(&quot;outside for&quot;);
		String nestedJSON = JsonUnflattener.unflatten(testDataJSONObject.toString());
		try{
		inputFieldsJSONArray.put(new JSONObject(nestedJSON));
		} catch(Exception e){
			log.info(e.toString());
		}
		//log.info(&quot;added to json array&quot;);
	}
	count++;
}

//14-Oct-2019-Selva(Replace Null,NULL string to null value)

//log.info(&quot;Final input fields array: &quot;+inputFieldsJSONArray.toString());
//rplaceNULL------
String null_1=&quot;\&quot;NULL\&quot;&quot;;
String null_2=&quot;\&quot;Null\&quot;&quot;;
String  rplaceNULLinPayLoad= inputFieldsJSONArray.toString();
rplaceNULLinPayLoad = rplaceNULLinPayLoad.replace(null_1,&quot;\1null&quot;);
rplaceNULLinPayLoad = rplaceNULLinPayLoad.replace(null_2,&quot;\2null&quot;);
//vars.put(&quot;inputFieldsJsonArray&quot;,inputFieldsJSONArray.toString()); ---OLD

//16-Oct-2019-Selva (Date conversion mm/dd/yyyy to yyyy/mm/dd
//log.info(&quot;-------------&quot;+rplaceNULLinPayLoad);
String payloadDateConversion = rplaceNULLinPayLoad;

	  String regex = &quot;(\\d{1,2}/\\d{1,2}/\\d{4}|\\d{1,2}/\\d{1,2})&quot;;
	  // pattern_Match
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(payloadDateConversion);      
		HashSet  set=new HashSet(); 
        HashSet  set2=new HashSet(); 
        int count = 0;
        //log.info(&quot;----1&quot;);
         while (matcher.find()){
        String groupValue =matcher.group();
        boolean isDate = false;
          String datePattern = &quot;\\d{1,2}/\\d{1,2}/\\d{4}&quot;;      
          isDate = groupValue.matches(datePattern);
          //log.info(&quot;expectedResultsFile-Check this is Date...? &quot;+groupValue+&quot;---&gt;&quot;+String.valueOf(isDate));
          if(isDate)
          {
              count++;
              set.add(groupValue);
          }
         }
    ArrayList  listSort = new ArrayList(set);
    log.info(String.valueOf(listSort));
    log.info(&quot;Size--&gt;&quot;+String.valueOf(listSort.size()));
    for(int i=0;i&lt;listSort.size();i++)
     {
        //log.info(String.valueOf(listSort.get(i)));
        String[] a=listSort.get(i).split(&quot;/&quot;);
        int  v = Integer.valueOf(a[0]); 
        if(10&lt;=v)
        {
            String beforeDateConversion = String.valueOf(listSort.get(i));
             Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);            
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            log.info(beforeDateConversion+&quot;----&gt;&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);      
            }
    else
        {
          set2.add(listSort.get(i));
        }
   }         
         //log.info(&quot;Total date count is.....&quot;+String.valueOf(count));
         Iterator itr=set2.iterator();  
         while(itr.hasNext()){  
            //log.info(String.valueOf(itr.next())); 
            String beforeDateConversion = String.valueOf(itr.next());
            Boolean check =false;
            //log.info(&quot;beforeDateConversion :&quot;+beforeDateConversion);
            Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);           
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            //log.info(&quot;afterDateConversion :&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);
             }
 
	  	//vars.put(&quot;payloadDateConversion&quot;,payloadDateConversion);
	  	vars.put(&quot;inputFieldsJsonArray&quot;,payloadDateConversion);
         

</stringProp>
                  <stringProp name="BeanShellSampler.filename"></stringProp>
                  <stringProp name="BeanShellSampler.parameters"></stringProp>
                  <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                </BeanShellSampler>
                <hashTree/>
              </hashTree>
              <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler- Expected Results" enabled="true">
                <stringProp name="BeanShellSampler.query">import org.json.JSONArray;
import org.json.JSONObject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
import java.util.regex.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;
// 
try {
//log.info(&quot;I am inside CSV to JSON Converter&quot;);
String headerLine;

BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;expectedResultsFile&quot;)));
		if ((line = brTest.readLine()) != null) {
			headerLine = line;//.replace(&quot;/&quot;,&quot;.&quot;);
		}
brTest.close();


//log.info(&quot;Header Line...&quot;+headerLine);
String[] headerLineSplit = headerLine.split(&quot;,&quot;);
String regex=&quot;/\\d+/&quot;;
for (int i=0;i&lt;headerLineSplit.length;i++) {
	Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
	Matcher matcher = pattern.matcher(headerLineSplit[i]);
	if (matcher.find()) {
		//log.info(&quot;found&quot;);
		String stringToBeReplaced = matcher.group(0).substring(0,(matcher.group(0).length()-1));
		//log.info(&quot;String to be replaced********&quot;+stringToBeReplaced);
		String replacementString = stringToBeReplaced.replace(&quot;/&quot;,&quot;[&quot;);
		//log.info(&quot;replacement string***********&quot;+replacementString);
		replacementString= replacementString.concat(&quot;]&quot;);
		//log.info(&quot;stringToBeReplaced...&quot;+stringToBeReplaced);
		//log.info(&quot;replacementString...&quot;+replacementString);
		headerLineSplit[i]=headerLineSplit[i].replace(stringToBeReplaced,replacementString);
		//log.info(&quot;headerLineSplit[i] after replacement: &quot;+headerLineSplit[i]);
		//headerLineSplit[i]=headerLineSplit[i].replaceAll(&quot;
	}
	headerLineSplit[i]=headerLineSplit[i].replace(&quot;/&quot;,&quot;.&quot;);
	
}

JSONArray inputFieldsJSONArray = new JSONArray();
JSONObject testDataJSONObject;
int count=0;
BufferedReader brTest = new BufferedReader(new FileReader(vars.get(&quot;expectedResultsFile&quot;)));
while (((line = brTest.readLine()) != null)) {
	if (count&gt;0) {
		String[] testDataSplit = line.split(&quot;,&quot;);
		testDataJSONObject = new JSONObject();
		//log.info(&quot;Header row length :&quot;+String.valueOf(headerLineSplit.length));
		//log.info(&quot;Test Data length :&quot;+String.valueOf(testDataSplit.length));
		for (int i=0;i&lt;headerLineSplit.length;i++) {
			//log.info(String.valueOf(i));
			//log.info(headerLineSplit[i]);
			//log.info(testDataSplit[i]);
			//log.info(headerLineSplit[i]);
			if (i&lt;testDataSplit.length){
				//log.info(&quot;testDataSplit[i]: &quot;+testDataSplit[i]);
				//if (testDataSplit[i].equals(&quot;IGNORE&quot;)) log.info(&quot;reached ignore case.....&quot;);
				//if (!testDataSplit[i].equals(&quot;IGNORE&quot;)) {
				//log.info(&quot;data avl&quot;);
					if (testDataSplit[i].length()==0 || testDataSplit[i].equals(&quot;null&quot;))
						testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
					else {
						if (testDataSplit[i].equalsIgnoreCase(&quot;true&quot;) || testDataSplit[i].equalsIgnoreCase(&quot;false&quot;)) {
							Boolean convertedValue = Boolean.parseBoolean(testDataSplit[i]);
							testDataJSONObject.put(headerLineSplit[i],convertedValue);	
						} else {
							try {
								Integer convertedValue = Integer.parseInt(testDataSplit[i]);
								testDataJSONObject.put(headerLineSplit[i],convertedValue);	
							} catch (Exception e) {
								try {
									Double convertedValue = Double.parseDouble(testDataSplit[i]);
									testDataJSONObject.put(headerLineSplit[i],convertedValue);	
								} catch (Exception e) {
									//log.info(&quot;Is this ignore? &quot;+testDataSplit[i]);
									if (!testDataSplit[i].equals(&quot;IGNORE&quot;)) testDataJSONObject.put(headerLineSplit[i],testDataSplit[i]);	
								}
							}
						}
						
					}
				//}
			}else{ 
				//log.info(&quot;data not avl&quot;);
				//log.info(&quot;test data is: &quot;+testDataSplit[i]);
				testDataJSONObject.put(headerLineSplit[i],JSONObject.NULL);
			}
			//log.info(String.valueOf(i)+&quot; - &quot;+testDataJSONObject.toString());
		}
		//log.info(&quot;outside for&quot;);
		//log.info(&quot;Test Data JSON OBJ - &quot;+testDataJSONObject.toString());
		String nestedJSON = JsonUnflattener.unflatten(testDataJSONObject.toString());
		try{
			inputFieldsJSONArray.put(new JSONObject(nestedJSON));
		} catch(Exception e){
			log.info(e.toString());
		}
		//log.info(&quot;added to json array&quot;);
	}
	count++;
}
//log.info(&quot;Final expected results array: &quot;+inputFieldsJSONArray.toString());



String payloadDateConversion = inputFieldsJSONArray.toString();

log.info(&quot;payloadDateConversion----&gt;&quot;+payloadDateConversion);

	  String regex = &quot;(\\d{1,2}/\\d{1,2}/\\d{4}|\\d{1,2}/\\d{1,2})&quot;;
	  // pattern_Match
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(payloadDateConversion);      
		HashSet  set=new HashSet(); 
        HashSet  set2=new HashSet(); 
        int count = 0;
        //log.info(&quot;----1&quot;);
         while (matcher.find()){
        String groupValue =matcher.group();
        boolean isDate = false;
          String datePattern = &quot;\\d{1,2}/\\d{1,2}/\\d{4}&quot;;      
          isDate = groupValue.matches(datePattern);
          //log.info(&quot;expectedResultsFile-Check this is Date...? &quot;+groupValue+&quot;---&gt;&quot;+String.valueOf(isDate));
          if(isDate)
          {
              count++;
              set.add(groupValue);
          }
         }
    ArrayList  listSort = new ArrayList(set);
    log.info(String.valueOf(listSort));
    log.info(&quot;Size--&gt;&quot;+String.valueOf(listSort.size()));
    for(int i=0;i&lt;listSort.size();i++)
     {
        //log.info(String.valueOf(listSort.get(i)));
        String[] a=listSort.get(i).split(&quot;/&quot;);
        int  v = Integer.valueOf(a[0]); 
        if(10&lt;=v)
        {
            String beforeDateConversion = String.valueOf(listSort.get(i));
             Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);            
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            log.info(beforeDateConversion+&quot;----&gt;&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);      
            }
    else
        {
          set2.add(listSort.get(i));
        }
   }         
         //log.info(&quot;Total date count is.....&quot;+String.valueOf(count));
         Iterator itr=set2.iterator();  
         while(itr.hasNext()){  
            //log.info(String.valueOf(itr.next())); 
            String beforeDateConversion = String.valueOf(itr.next());
            Boolean check =false;
            //log.info(&quot;beforeDateConversion :&quot;+beforeDateConversion);
            Date dateFinal=new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(beforeDateConversion);           
            String afterDateConversion =String.valueOf((new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(dateFinal)));
            log.info(beforeDateConversion+&quot;----&gt;&quot;+afterDateConversion);
            payloadDateConversion=payloadDateConversion.replace(beforeDateConversion,afterDateConversion);
             }
	         
vars.put(&quot;expectedResultsArray&quot;,payloadDateConversion);
} catch(Exception e) {	
	String errorCode=&quot;18000&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}

</stringProp>
                <stringProp name="BeanShellSampler.filename"></stringProp>
                <stringProp name="BeanShellSampler.parameters"></stringProp>
                <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
              </BeanShellSampler>
              <hashTree/>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Store the input and expected files JSON post conversion" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Store the input and expected files JSON post conversion" enabled="true">
                  <stringProp name="filename"></stringProp>
                  <stringProp name="parameters"></stringProp>
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="script">//Store input and expected files JSON post conversion
import org.json.JSONArray;
import org.json.JSONObject;
import java.lang.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the input and expected files JSON post conversion - beanshell starts&quot;);
	long millis = System.currentTimeMillis();
	String trackingFile = vars.get(&quot;jsonWorkbenchPath&quot;).concat(&quot;jsonPayloadTracker_&quot;).concat(String.valueOf(millis)).concat(&quot;.csv&quot;);
	vars.put(&quot;payloadTrackingFile&quot;,trackingFile);
	f3 = new FileOutputStream(trackingFile,false);
	f3.close();
	if(vars.get(&quot;fileType&quot;).equalsIgnoreCase(&quot;json&quot;))
	{
		vars.put(&quot;inputFieldsJsonArray&quot;,null);
	}
	JSONArray newInputFieldsArray = new JSONArray(vars.get(&quot;inputFieldsJsonArray&quot;));
	if (debug) log.info(&quot;InputFields JSON Array: &quot;+vars.get(&quot;inputFieldsJsonArray&quot;));
	JSONArray newExpectedResultsArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
	if (debug) log.info(&quot;Expected Results JSON Array: &quot;+vars.get(&quot;expectedResultsArray&quot;));	
	JSONArray newUrlInputFieldArray = new JSONArray(vars.get(&quot;urlInputFieldArray&quot;));
	if (debug) log.info(&quot;URL Parameter Fields JSON Array: &quot;+vars.get(&quot;urlInputFieldArray&quot;));	
//Log for each API 
String logFilePath =vars.get(&quot;logFilePath&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;.txt&quot;);
log.info(logFilePath);
f5 = new FileOutputStream(logFilePath,true);
		PrintStream p5 = new PrintStream(f5);
		this.interpreter.setOut(p5); 
		print(vars.get(&quot;apiName&quot;));
		print(&quot;inputFieldsJsonArray:&quot; + vars.get(&quot;inputFieldsJsonArray&quot;));
		print(&quot;expectedResultsArray: &quot;+vars.get(&quot;expectedResultsArray&quot;));
		print(&quot;urlInputFieldArray: &quot;+vars.get(&quot;urlInputFieldArray&quot;));
		f5.close();




		
	for (int i=0;i&lt;newUrlInputFieldArray.length();i++) {
		String jsonPayloadFileName =&quot;&quot;;
		if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
			jsonPayloadFileName = vars.get(&quot;timeStampedJsonPayloadPath&quot;).concat(&quot;testScenario_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		} 
		String expectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;).concat(&quot;expectedResults_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		String urlInputFieldFileName = vars.get(&quot;timeStampedJsonWorkbenchURLParametersPath&quot;).concat(&quot;urlInputFields_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		//create JSON Payload and expected results Tracking File
		f2 = new FileOutputStream(trackingFile,true);
		PrintStream p2 = new PrintStream(f2);
		this.interpreter.setOut(p2); 
		print((i+1)+&quot;,&quot;+jsonPayloadFileName+&quot;,&quot;+expectedResultsFileName+&quot;,&quot;+urlInputFieldFileName);
		f2.close();
		//Create JSON Payload file
		if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
			f = new FileOutputStream(jsonPayloadFileName, false);
			p = new PrintStream(f); 
			this.interpreter.setOut(p); 
			print(newInputFieldsArray.getJSONObject(i));
			f.close();
			System.out.println(&quot;18001&quot;);
		}
		//Create Expected Payload file
		f4 = new FileOutputStream(expectedResultsFileName, false);
		p4 = new PrintStream(f4); 
		this.interpreter.setOut(p4); 
		print(newExpectedResultsArray.getJSONObject(i));
		f4.close();	
		//Create URLInputField File	
		f5 = new FileOutputStream(urlInputFieldFileName, false);
		p5 = new PrintStream(f5); 
		this.interpreter.setOut(p5); 
		print(newUrlInputFieldArray.getJSONObject(i));
		f5.close();	
System.out.println(&quot;18002&quot;);
	}
	if (debug) log.info(&quot;Store the input and expected files JSON post conversion - beanshell ends&quot;);
} catch(Exception e) {
	String errorCode=&quot;1800&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}
</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Find the number of scenarios to be validated" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">String fileName = vars.get(&quot;payloadTrackingFile&quot;);
log.info(&quot;Filename: &quot;+fileName);
int numberOfRowsInCSV=0;

BufferedReader brTest = new BufferedReader(new FileReader(fileName));
		while ((line = brTest.readLine()) != null) {
			numberOfRowsInCSV++;
		}
brTest.close();
vars.put(&quot;numberOfRowsInCSV&quot;,String.valueOf(numberOfRowsInCSV));
</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token" enabled="true">
                <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                  <collectionProp name="Arguments.arguments">
                    <elementProp name="" elementType="HTTPArgument">
                      <boolProp name="HTTPArgument.always_encode">false</boolProp>
                      <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                      <stringProp name="Argument.metadata">=</stringProp>
                    </elementProp>
                  </collectionProp>
                </elementProp>
                <stringProp name="HTTPSampler.domain">${server}</stringProp>
                <stringProp name="HTTPSampler.port"></stringProp>
                <stringProp name="HTTPSampler.protocol">https</stringProp>
                <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
                <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                <stringProp name="HTTPSampler.response_timeout"></stringProp>
                <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
              </HTTPSamplerProxy>
              <hashTree>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="false">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                      <stringProp name="Header.value">wepemnefret</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">uuid</stringProp>
                      <stringProp name="Header.value">asdkasd</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                  <collectionProp name="HeaderManager.headers">
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">Content-Type</stringProp>
                      <stringProp name="Header.value">application/json</stringProp>
                    </elementProp>
                    <elementProp name="" elementType="Header">
                      <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                      <stringProp name="Header.value">testground</stringProp>
                    </elementProp>
                  </collectionProp>
                </HeaderManager>
                <hashTree/>
                <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                  <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                  <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                  <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                  <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                </JSONPostProcessor>
                <hashTree/>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - Record Thread Start Time" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//RecordStartTime
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller_CSV" enabled="true">
                <stringProp name="IfController.condition">&quot;${fileType}&quot;==&quot;csv&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
                  <boolProp name="LoopController.continue_forever">true</boolProp>
                  <stringProp name="LoopController.loops">${numberOfRowsInCSV}</stringProp>
                </LoopController>
                <hashTree>
                  <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read data from payload tracker" enabled="true">
                    <boolProp name="WAITING">true</boolProp>
                    <boolProp name="SUCCESFULL">true</boolProp>
                    <stringProp name="RESPONSE_CODE">200</stringProp>
                    <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                    <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                    <stringProp name="RESPONSE_DATA">${__CSVRead(${payloadTrackingFile},0)}|${__CSVRead(${payloadTrackingFile},1)}|${__CSVRead(${payloadTrackingFile},2)}|${__CSVRead(${payloadTrackingFile},3)}${__CSVRead(${payloadTrackingFile},next)}</stringProp>
                    <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                    <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                    <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                    <stringProp name="URL"></stringProp>
                    <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                  </kg.apc.jmeter.samplers.DummySampler>
                  <hashTree>
                    <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                      <boolProp name="resetInterpreter">false</boolProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">//testScenarioNumber,payloadFilePath,expectedResultsFilePath,urlInputFieldsFilePath
String responseMsg = prev.getResponseDataAsString();
log.info(responseMsg);
String[] responseMsgSplit = responseMsg.split(&quot;\\|&quot;);
vars.put(&quot;testScenarioNumber&quot;,responseMsgSplit[0]);
vars.put(&quot;payloadFilePath&quot;,responseMsgSplit[1]);
vars.put(&quot;expectedResultsFilePath&quot;,responseMsgSplit[2]);
vars.put(&quot;urlInputFieldsFilePath&quot;,responseMsgSplit[3]);
log.info(responseMsgSplit[0]);
log.info(responseMsgSplit[1]);
log.info(responseMsgSplit[2]);
log.info(responseMsgSplit[3]);</stringProp>
                    </BeanShellPostProcessor>
                    <hashTree/>
                  </hashTree>
                  <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                    <stringProp name="IfController.condition">&quot;${testScenarioNumber}&quot;!=&quot;&lt;EOF&gt;&quot;</stringProp>
                    <boolProp name="IfController.evaluateAll">false</boolProp>
                  </IfController>
                  <hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Expected Results into a variable" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__FileToString(${expectedResultsFilePath},,expectedResults)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree/>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If input payload is applicable" enabled="true">
                      <stringProp name="IfController.condition">&quot;${inputPayloadExistence}&quot;==&quot;yes&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read JSON Payload into a variable" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${payloadFilePath},,jsonPayload)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree/>
                    </hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read URL Parameter into a variable" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__FileToString(${urlInputFieldsFilePath},,urlInputParameters)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree/>
                    <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler - Check elapsed time" enabled="true">
                      <stringProp name="BeanShellSampler.query">//Check Elapsed Time
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
long startTime=Long.valueOf(vars.get(&quot;startTime_&quot;+ctx.getThreadNum()));
double diff = (timeMilli-startTime)/60000;

if (diff &gt;= 18.0) {
	vars.put(&quot;relogin&quot;,&quot;1&quot;);
} else {
	vars.put(&quot;relogin&quot;,&quot;0&quot;);
}
</stringProp>
                      <stringProp name="BeanShellSampler.filename"></stringProp>
                      <stringProp name="BeanShellSampler.parameters"></stringProp>
                      <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                    </BeanShellSampler>
                    <hashTree/>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If elapsed time" enabled="true">
                      <stringProp name="IfController.condition">&quot;${relogin}&quot;==&quot;1&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token " enabled="true">
                        <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                        <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                          <collectionProp name="Arguments.arguments">
                            <elementProp name="" elementType="HTTPArgument">
                              <boolProp name="HTTPArgument.always_encode">false</boolProp>
                              <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                              <stringProp name="Argument.metadata">=</stringProp>
                            </elementProp>
                          </collectionProp>
                        </elementProp>
                        <stringProp name="HTTPSampler.domain">${server}</stringProp>
                        <stringProp name="HTTPSampler.port"></stringProp>
                        <stringProp name="HTTPSampler.protocol">https</stringProp>
                        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                        <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                        <stringProp name="HTTPSampler.method">POST</stringProp>
                        <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                        <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                        <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                        <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                        <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                        <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                        <stringProp name="HTTPSampler.response_timeout"></stringProp>
                        <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                      </HTTPSamplerProxy>
                      <hashTree>
                        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                          <collectionProp name="HeaderManager.headers">
                            <elementProp name="" elementType="Header">
                              <stringProp name="Header.name">Content-Type</stringProp>
                              <stringProp name="Header.value">application/json</stringProp>
                            </elementProp>
                            <elementProp name="" elementType="Header">
                              <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                              <stringProp name="Header.value">testground</stringProp>
                            </elementProp>
                          </collectionProp>
                        </HeaderManager>
                        <hashTree/>
                        <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                          <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                          <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                          <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                          <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                        </JSONPostProcessor>
                        <hashTree/>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - timeCheck" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//RecordStartTime2
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
vars.put(&quot;relogin&quot;,&quot;0&quot;);</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                    </hashTree>
                    <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="API Name - ${apiName}" enabled="true">
                      <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                        <collectionProp name="Arguments.arguments"/>
                      </elementProp>
                      <stringProp name="HTTPSampler.domain">${server}</stringProp>
                      <stringProp name="HTTPSampler.port">${port}</stringProp>
                      <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
                      <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                      <stringProp name="HTTPSampler.path"></stringProp>
                      <stringProp name="HTTPSampler.method">POST</stringProp>
                      <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                      <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                      <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                      <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                      <stringProp name="HTTPSampler.connect_timeout">120000</stringProp>
                      <stringProp name="HTTPSampler.response_timeout"></stringProp>
                      <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                    </HTTPSamplerProxy>
                    <hashTree>
                      <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                        <collectionProp name="HeaderManager.headers"/>
                      </HeaderManager>
                      <hashTree/>
                      <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Manage HTTP  Headers and api method for the REST API" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">
//Add any additional headers as required
import org.apache.jmeter.protocol.http.control.Header;
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell starts&quot;);
	sampler.setMethod(vars.get(&quot;apiMethod&quot;)); 
	JSONObject urlInputFields = new JSONObject(vars.get(&quot;urlInputParameters&quot;));
	if (debug) log.info(&quot;URL Input fields: &quot;+urlInputFields.toString());
	Object aObj = urlInputFields.get(&quot;urlParameter&quot;);
	String urlParameterValue=null;
	String apiFullPathValue =&quot;NA&quot;;
	if(aObj instanceof Integer){
   if (debug) log.info(&quot;Integer : &quot;+String.valueOf(aObj));
     urlParameterValue=urlInputFields.getInt(&quot;urlParameter&quot;).toString();
}
else
{
	if (debug) log.info(&quot;String :&quot;+String.valueOf(aObj));
	urlParameterValue=urlInputFields.getString(&quot;urlParameter&quot;);
}
if (debug) log.info(&quot;---&quot;+urlParameterValue);
	if (urlParameterValue.length()&gt;0 &amp;&amp; !urlParameterValue.equals(null) &amp;&amp; !urlParameterValue.equals(&quot;NA&quot;))
	{
		if (debug)log.info(&quot;--------------path with parameter&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue));
		apiFullPathValue = vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue);
	} else {
		if (debug) log.info(&quot;--------------only path&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;));		
		apiFullPathValue = vars.get(&quot;apiPath&quot;);
	}
	vars.put(&quot;apiFullPathValue&quot;,apiFullPathValue);
	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
		if (vars.get(&quot;jsonPayload&quot;).length()&gt;5) {
			sampler.setPostBodyRaw(true);
			sampler.addNonEncodedArgument(&quot;&quot;,vars.get(&quot;jsonPayload&quot;),&quot;&quot;);
		}
	}
	String apiHeadersString = &quot;&quot;;
	if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;)) apiHeadersString=vars.get(&quot;apiHeadersGETPUT&quot;); 
	else apiHeadersString=vars.get(&quot;apiHeaders&quot;);
	log.info(&quot;API Header String: &quot;+apiHeadersString);
	/*Collection c = sampler.getHeaderManager().getHeaders();
	for (Iterator i = c.iterator(); i.hasNext();) { 
       log.info(i.next());
	}*/
       
	int countOfExistingHeaders = sampler.getHeaderManager().size();
	if (debug) log.info(&quot;Count of headers: &quot;+String.valueOf(countOfExistingHeaders));
	if (countOfExistingHeaders==0) {
		//log.info(&quot;3&quot;);
		JSONObject apiHeadersObject = new JSONObject(apiHeadersString);
		//log.info(&quot;4&quot;);
		Iterator newKeys = apiHeadersObject.keys();
		while (newKeys.hasNext()) {
			String newKey = newKeys.next();
			sampler.getHeaderManager().add(new Header(newKey,apiHeadersObject.getString(newKey)));
		}
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	} else {
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	}


	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;1900&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}
</stringProp>
                      </BeanShellPreProcessor>
                      <hashTree/>
                      <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Store the payload injection date and time" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//Store the payload injection date and time
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String payloadInjectionDate = dateFormatter.format(cal.getTime());
	String payloadInjectionTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;payloadInjectionDate&quot;,payloadInjectionDate);
	vars.put(&quot;payloadInjectionTime&quot;,payloadInjectionTime);
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2000&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode);
	f.close();
}</stringProp>
                      </BeanShellPreProcessor>
                      <hashTree/>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Store response JSON and validate response code" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//Store results JSON in the appropriate folder
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store response JSON and validate response code - beanshell starts&quot;);
	String jsonResultsFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;jsonOutput&quot;).concat(&quot;_&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;.json&quot;);
	vars.put(&quot;jsonResultsFileName&quot;,jsonResultsFileName);
	if (debug) log.info(jsonResultsFileName);
	f = new FileOutputStream(jsonResultsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(prev.getResponseDataAsString());
	f.close();
	//Create JSON Object for Actual Results
	JSONObject actualResult = new JSONObject();
	if (prev.getResponseDataAsString().toString().length()&gt;0) {
		actualResult = new JSONObject(prev.getResponseDataAsString());
	}
	//validate response Code
	String expectedResults = vars.get(&quot;expectedResults&quot;);
	JSONObject expectedResultsJSON = new JSONObject(expectedResults);
	int expectedResponseCode = expectedResultsJSON.get(&quot;expectedResponseCode&quot;);
	//JSONObject newExpectedResults after trimming the expected response code;
	if (String.valueOf(expectedResponseCode).equals(prev.getResponseCode())) {
		JSONObject newExpectedResult = new JSONObject();
		Iterator keys = expectedResultsJSON.keys();
		while(keys.hasNext()) {
		    String key = keys.next();
		    if (!key.equals(&quot;expectedResponseCode&quot;)) {
	    			newExpectedResult.put(key,expectedResultsJSON.get(key));
		    }
		}
		if (debug) log.info(actualResult.toString());
		if (debug) log.info(newExpectedResult.toString());
		vars.put(&quot;newExpectedResult&quot;,newExpectedResult.toString());
		vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
	} else {
		vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
	}
	if (debug) log.info(&quot;Store response JSON and validate response code - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2100&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}


</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Validate individual elements in JSON with that of the expected results" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//Validate individual elements in JSON
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONObject;
import com.github.wnameless.json.flattener.JsonFlattener;
try {
	Boolean debug;
	String errorCode=&quot;&quot;;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Validate individual elements in JSON with that of the expected results - beanshell starts&quot;);
	String testResult;
	String reasonForFailure=&quot;&quot;;
	if (vars.get(&quot;responseCodeValidation&quot;).equals(&quot;PASS&quot;)) {
		String jsonStringActualResults = prev.getResponseDataAsString().toString();
		if (debug) log.info(&quot;JSON String Expected Results&quot;);
		if (debug) log.info(vars.get(&quot;newExpectedResult&quot;));
		if (debug) log.info(&quot;JSON String Modified Results&quot;);
		Map checkMap = JsonFlattener.flattenAsMap(vars.get(&quot;newExpectedResult&quot;));
		JSONObject checkMapJSONObject = new JSONObject(checkMap.toString());
		Iterator checkKeys = checkMapJSONObject.keys();
		int emptyKey=0;
		int count=0;
		while (checkKeys.hasNext()) {
			count++;
			String checkKey = checkKeys.next();
			if (checkMapJSONObject.get(checkKey).toString().equals(&quot;{}&quot;)) {
				emptyKey++;
			}
		}
		String expectedResultsModified = &quot;{}&quot;;
		if (count!=emptyKey)
			expectedResultsModified = vars.get(&quot;newExpectedResult&quot;).replace(&quot;{},&quot;,&quot;&quot;).replace(&quot;{}]&quot;,&quot;]&quot;).replace(&quot;{}}&quot;,&quot;}&quot;)
			.replace(&quot;,]&quot;,&quot;]&quot;).replace(&quot;,}&quot;,&quot;}&quot;);
		if (debug) log.info(&quot;Expected Rsults modified&quot;);
		if (debug) log.info(expectedResultsModified);
		if (new JSONObject(expectedResultsModified).length() &gt; 0) {
				Map flattenedJsonMapActualResults = JsonFlattener.flattenAsMap(jsonStringActualResults);
				Map flattenedJsonMapExpectedResults = JsonFlattener.flattenAsMap(expectedResultsModified);
				JSONObject flatteneddActualResults = new JSONObject(flattenedJsonMapActualResults.toString());
				JSONObject flatteneddExpectedResults = new JSONObject(flattenedJsonMapExpectedResults.toString());
				if (debug) log.info(&quot;Expected Results&quot;);
			 	if (debug) log.info(flatteneddExpectedResults.toString());
				if (debug) log.info(&quot;Actual Results&quot;);
				if (debug) log.info(flatteneddActualResults.toString());
				Iterator newKeys = flatteneddExpectedResults.keys();
				while (newKeys.hasNext()) {
					String newKey = newKeys.next();
					if (flatteneddActualResults.has(newKey)) {
						Object expectedResultObject= flatteneddExpectedResults.get(newKey);
						Object actualResultObject = flatteneddActualResults.get(newKey);
						if (expectedResultObject instanceof String) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a String and its value is &quot;+String.valueOf(expectedResultObject)); 
							if (debug) log.info(&quot;Actual =&gt;&quot; +newKey+&quot; is a String and its value is &quot;+String.valueOf(actualResultObject)); 
							if (String.valueOf(actualResultObject).equals(&quot;null&quot;)) {
								actualResultObject=&quot;&quot;;
							}
							if (String.valueOf(expectedResultObject).equals(String.valueOf(actualResultObject))) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
						} else if (expectedResultObject instanceof Integer) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a Integer and its value is &quot;+String.valueOf(expectedResultObject));	
							if (debug) log.info(&quot;Actual =&gt;&quot;+newKey+&quot; is a Integer and its value is &quot;+String.valueOf(actualResultObject));			
							//double expected = (double)expectedResultObject;
							//double actual = (double) actualResultObject;
							double expected = (double) Integer.parseInt(String.valueOf(expectedResultObject));
							double actual = (double) Double.parseDouble(String.valueOf(actualResultObject));
							
							if (Double.compare(expected,actual) == 0) {
							//if (String.valueOf(expectedResultObject).equals(String.valueOf(actualResultObject))) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
						} else if (expectedResultObject instanceof Double) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a Double and its value is &quot;+String.valueOf(expectedResultObject));	
							if (debug) log.info(&quot;Actual =&gt;&quot;+newKey+&quot; is a Double and its value is &quot;+String.valueOf(actualResultObject));			
							if (Double.compare(expectedResultObject,actualResultObject) == 0) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
					
						} else if (expectedResultObject instanceof Boolean) {
							if (debug) log.info(&quot;Expected -&gt;&quot;+newKey+&quot; is a Boolean and its value is &quot;+String.valueOf(expectedResultObject));	
							if (debug) log.info(&quot;Actual =&gt;&quot;+newKey+&quot; is a Boolean and its value is &quot;+String.valueOf(actualResultObject));			
					
							if (expectedResultObject==actualResultObject) {
								if (debug) log.info(&quot;Pass&quot;);
								testResult=&quot;PASS&quot;;
							} else {
								testResult=&quot;FAIL&quot;;
								if (debug) log.info(&quot;fail&quot;);
							}
						} 
						if (testResult.equals(&quot;FAIL&quot;)) {
							reasonForFailure = reasonForFailure.concat(&quot;|&quot;).concat(&quot;Expected value for &quot;).concat(newKey).concat(&quot; is &quot;).concat(String.valueOf(expectedResultObject)).concat(&quot; and actual value is &quot;).concat(String.valueOf(actualResultObject));
							if (debug) log.info(&quot;Reason For Failure: &quot;+reasonForFailure);
							//break;
						}
					} else {
						testResult = &quot;FAIL&quot;;
						reasonForFailure = reasonForFailure.concat(&quot;|&quot;).concat(newKey).concat(&quot; not present in the results JSON Object&quot;);
						//break;
					}
				}
		} else {
			testResult = &quot;PASS&quot;;
		}
	} else {
		testResult = &quot;FAIL&quot;;
		reasonForFailure = &quot;Actual response code received is &quot;+prev.getResponseCode();
	}
	if (reasonForFailure.length()&gt;0) testResult=&quot;FAIL&quot;;
////



//get_expectedResponseCode
int expectedResponseCode =0;
log.info(vars.get(&quot;expectedResultsArray&quot;));
JSONArray fetexpectedResponseCodeFromArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
int fetexpectedResponseCodeFromArraySize=fetexpectedResponseCodeFromArray.length();
int checkExpectedResponseCode = Integer.valueOf(vars.get(&quot;testScenarioNumber&quot;));
	for(int i=0;i&lt;fetexpectedResponseCodeFromArraySize;i++)
		{
			JSONObject newJSonObject = new JSONObject();
		
			newJSonObject = fetexpectedResponseCodeFromArray.getJSONObject((checkExpectedResponseCode-1));
			expectedResponseCode=newJSonObject.getInt(&quot;expectedResponseCode&quot;);	
		}
	if (debug) log.info(&quot;expectedResponseCode-:-&quot;+String.valueOf(expectedResponseCode));

	String actualResponseCode=&quot;NA&quot;;
	actualResponseCode =prev.getResponseCode();
 	
//	//Store Results in a csv file
	String resultToBeStored =vars.get(&quot;payloadInjectionDate&quot;).concat(&quot;,&quot;).concat(vars.get(&quot;payloadInjectionTime&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;moduleName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;payloadFilePath&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;jsonResultsFileName&quot;)).concat(&quot;,&quot;).concat(testResult).concat(&quot;,&quot;).concat(String.valueOf(expectedResponseCode)).concat(&quot;,&quot;).concat(actualResponseCode).concat(&quot;,&quot;).concat(vars.get(&quot;overallInputFile&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiMethod&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiFullPathValue&quot;)).concat(&quot;,&quot;).concat(reasonForFailure).concat(&quot;,&quot;).concat(vars.get(&quot;consentPerson&quot;));
	if (debug) log.info(resultToBeStored);
	f = new FileOutputStream(vars.get(&quot;apiResultsFileName&quot;),true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(resultToBeStored);
	f.close();
	//String overallResult = vars.get(&quot;apiTestResult&quot;);
	if (testResult.equals(&quot;FAIL&quot;) &amp;&amp; vars.get(&quot;apiTestResult&quot;).equals(&quot;PASS&quot;)) vars.put(&quot;apiTestResult&quot;,&quot;FAIL&quot;);
	if (debug) log.info(&quot;Validate individual elements in JSON with that of the expected results - beanshell ends&quot;); 
} catch (Exception e) {
	String errorCode=&quot;2200&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                    </hashTree>
                  </hashTree>
                </hashTree>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller_JSON" enabled="true">
                <stringProp name="IfController.condition">&quot;${fileType}&quot;==&quot;json&quot; &amp;&amp; &quot;${mysql}&quot;==&quot;n&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                  <stringProp name="IfController.condition">&quot;${testScenarioNumber}&quot;!=&quot;&lt;EOF&gt;&quot;</stringProp>
                  <boolProp name="IfController.evaluateAll">false</boolProp>
                </IfController>
                <hashTree>
                  <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Check JSON  file is available?" enabled="true">
                    <boolProp name="WAITING">true</boolProp>
                    <boolProp name="SUCCESFULL">true</boolProp>
                    <stringProp name="RESPONSE_CODE">200</stringProp>
                    <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                    <stringProp name="REQUEST_DATA">${expectedJsonPath}
${payloadJsonPath}

${jsonLoop}</stringProp>
                    <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                    <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                    <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                    <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                    <stringProp name="URL"></stringProp>
                    <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                  </kg.apc.jmeter.samplers.DummySampler>
                  <hashTree>
                    <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor_FileCheck" enabled="true">
                      <boolProp name="resetInterpreter">false</boolProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">//check_Json_File
import java.util.*;
String payloadJsonPath = vars.get(&quot;payloadJsonPath&quot;);
String expectedJsonPath=vars.get(&quot;expectedJsonPath&quot;);

String payloadJsonFileName = vars.get(&quot;payloadJSON&quot;);
String expectedJsonFileName = vars.get(&quot;expectedJSON&quot;);

String payloadFilePathString=payloadJsonPath.concat(payloadJsonFileName);
String expectedFilePathString=expectedJsonPath.concat(expectedJsonFileName);


ArrayList  listValue = new ArrayList();
listValue.add(payloadFilePathString);
listValue.add(expectedFilePathString);

vars.put(&quot;payloadFilePathString&quot;,payloadFilePathString);
vars.put(&quot;expectedFilePathString&quot;,expectedFilePathString);
// log.info(String.valueOf(listValue));

for(int i=0;i&lt;listValue.size();i++)
	{
	//log.info(listValue.get(i));
		
		File f = new File(listValue.get(i));
		if(f.exists() &amp;&amp; !f.isDirectory()) { 
		   vars.put(&quot;jsonFileCheck&quot;,&quot;y&quot;);
		   
		}
			else
			{
			log.info(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			 vars.put(&quot;fileCheck&quot;,&quot;n&quot;);
			 System.out.println(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			}
	}
	
</stringProp>
                    </BeanShellPreProcessor>
                    <hashTree/>
                  </hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${jsonLoop}</stringProp>
                  </LoopController>
                  <hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read data from payload tracker" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__CSVRead(${payloadTrackingFile},0)}|${__CSVRead(${payloadTrackingFile},1)}|${__CSVRead(${payloadTrackingFile},2)}|${__CSVRead(${payloadTrackingFile},3)}${__CSVRead(${payloadTrackingFile},next)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//testScenarioNumber,payloadFilePath,expectedResultsFilePath,urlInputFieldsFilePath
String responseMsg = prev.getResponseDataAsString();
log.info(responseMsg);
String[] responseMsgSplit = responseMsg.split(&quot;\\|&quot;);
vars.put(&quot;testScenarioNumber&quot;,responseMsgSplit[0]);
vars.put(&quot;payloadFilePath&quot;,responseMsgSplit[1]);
vars.put(&quot;expectedResultsFilePath&quot;,responseMsgSplit[2]);
vars.put(&quot;urlInputFieldsFilePath&quot;,responseMsgSplit[3]);
log.info(responseMsgSplit[0]);
log.info(responseMsgSplit[1]);
log.info(responseMsgSplit[2]);
log.info(responseMsgSplit[3]);</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                    </hashTree>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                      <stringProp name="IfController.condition">&quot;${jsonFileCheck}&quot;==&quot;y&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Json Payload File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${payloadFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Json Payload File
import org.json.JSONArray;
import org.json.JSONObject;

JSONArray newInputFieldsJsonArray = new JSONArray();
String payloadDataArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(payloadDataArray);
log.info(String.valueOf(newJsonArray.length()));
int size=newJsonArray.length();
vars.put(&quot;numberOfRowsInCSV&quot;,String.valueOf(size));
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));
for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;apiName&quot;);
	log.info(apiName);
	Object payloadCheck =newJsonObject.get(&quot;payload&quot;);

	//check - &gt; match with apiname
	if(apiName.equalsIgnoreCase(testapiName))
	{		
			jsonPayloadFileName = vars.get(&quot;timeStampedJsonPayloadPath&quot;).concat(&quot;testScenario_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
			Object payloadCheck =newJsonObject.get(&quot;payload&quot;);
			f = new FileOutputStream(jsonPayloadFileName, false);
			p = new PrintStream(f); 
			this.interpreter.setOut(p); 
			print(payloadCheck);
			f.close();	
			vars.put(&quot;payloadFilePath&quot;,jsonPayloadFileName);	
			vars.put(&quot;jsonPayload&quot;,String.valueOf(payloadCheck));

			//If = scenario -&gt; get apimethod and apipath from json
			if(vars.get(&quot;scenario&quot;).equalsIgnoreCase(&quot;y&quot;))
			{
			String apiMethod = newJsonObject.get(&quot;apiMethod&quot;);
			String apiPath= newJsonObject.get(&quot;apiPath&quot;);
			vars.put(&quot;apiMethod&quot;,apiMethod);
			vars.put(&quot;apiPath&quot;,apiPath);	
			}
			break;
	}
		
}

</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Json Expected File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${expectedFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Json Expected File
import org.json.JSONArray;
import org.json.JSONObject;

JSONArray newExpectedResultsArray = new JSONArray();
String expectedResultArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(expectedResultArray);
//log.info(payloadDateArray);
log.info(String.valueOf(newJsonArray.length()));
//JSONObject newJsonObject = new JSONObject();
int size=newJsonArray.length();
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));
for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;apiName&quot;);	
	Object expectedCheck =newJsonObject.get(&quot;expected&quot;);
//	Object ignoreKeys = newJsonObject.get(&quot;ignore&quot;);
	//Check the expected result is Array ? or Object?
	if(expectedCheck instanceof JSONObject)
		{
//			log.info(&quot;---------&gt;jsonObject&quot;);
		 vars.put(&quot;jsonType&quot;,&quot;jsonObject&quot;);
		}else if(expectedCheck instanceof JSONArray)
			{
//				log.info(&quot;---------&gt;jsonArray&quot;);
			 vars.put(&quot;jsonType&quot;,&quot;jsonArray&quot;);	
			}
	
	vars.put(&quot;expectedResult&quot;,String.valueOf(expectedCheck));	
//	log.info(&quot;expectedObject--&gt;&quot;+String.valueOf(expectedCheck));	
	newExpectedResultsArray.put(expectedCheck);	
	if(apiName.equalsIgnoreCase(testapiName))
	{
		//log.info(&quot;expectedObject--&gt;AfterIf&quot;+String.valueOf(expectedCheck));
		//log.info(&quot;expectedObject--apiName-&gt;&quot;+apiName);
		vars.put(&quot;apiNameExpected&quot;,testapiName);
		Object expectedCheck =newJsonObject.get(&quot;expected&quot;);

		//ignoreKeys
//		JSONArray ignoreKeys = new JSONArray();
		Object ignoreKeys=newJsonObject.get(&quot;ignore&quot;);
		JSONArray commonIgnoreArray =newJsonObject.get(&quot;commonIgnore&quot;);
		vars.put(&quot;commonIgnoreArray&quot;,String.valueOf(commonIgnoreArray));
		vars.put(&quot;ignoreKeysArray&quot;,String.valueOf(ignoreKeys));
		log.info(String.valueOf(ignoreKeys));

		// selectedFields
		String apiNameCheck = vars.get(&quot;apiName&quot;);
		String selectedFieldsJson = vars.get(&quot;selectedFieldsJsonArray&quot;);
//		log.info(selectedFieldsJson);
		JSONArray selectedFieldsJsonArray = new JSONArray(selectedFieldsJson);
		int selectedFieldsJsonArraySize= selectedFieldsJsonArray.length();
//		log.info(String.valueOf(selectedFieldsJsonArraySize));
		for(int i=0;i&lt;selectedFieldsJsonArraySize;i++)
		{
			String arrayAPIName = selectedFieldsJsonArray.get(i);
//			log.info(arrayAPIName);
			if(apiNameCheck.equalsIgnoreCase(arrayAPIName))
			{
			JSONArray selectedFieldJSONkeysArray =newJsonObject.get(&quot;selectedFieldJSONkeys&quot;);
//			log.info(&quot;selectedFieldJSONkeysArray------&gt;&gt;&quot;+String.valueOf(selectedFieldJSONkeysArray));
			vars.put(&quot;selectedFieldJSONkeysArray&quot;,String.valueOf(selectedFieldJSONkeysArray));
				break;
			}
			
		}
		

		
		
		String expectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;).concat(&quot;expectedResults_for_API__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		
		//log.info(&quot;----&gt;&quot;+expectedResultsFileName);
		f4 = new FileOutputStream(expectedResultsFileName, false);
		p4 = new PrintStream(f4); 
		this.interpreter.setOut(p4); 
		print(expectedCheck);
		f4.close();	
		vars.put(&quot;jsonExpected&quot;,String.valueOf(expectedCheck));
		break;
	}		
}
//vars.put(&quot;expectedResultsArray&quot;,String.valueOf(newExpectedResultsArray));
//log.info(String.valueOf(newExpectedResultsArray));
</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read URL Parameter into a variable" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${urlInputFieldsFilePath},,urlInputParameters)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree/>
                      <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler - Check elapsed time" enabled="true">
                        <stringProp name="BeanShellSampler.query">//Check Elapsed Time
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
long startTime=Long.valueOf(vars.get(&quot;startTime_&quot;+ctx.getThreadNum()));
double diff = (timeMilli-startTime)/60000;

if (diff &gt;= 18.0) {
	vars.put(&quot;relogin&quot;,&quot;1&quot;);
} else {
	vars.put(&quot;relogin&quot;,&quot;0&quot;);
}
</stringProp>
                        <stringProp name="BeanShellSampler.filename"></stringProp>
                        <stringProp name="BeanShellSampler.parameters"></stringProp>
                        <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                      </BeanShellSampler>
                      <hashTree/>
                      <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If elapsed time" enabled="true">
                        <stringProp name="IfController.condition">&quot;${relogin}&quot;==&quot;1&quot;</stringProp>
                        <boolProp name="IfController.evaluateAll">false</boolProp>
                      </IfController>
                      <hashTree>
                        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token " enabled="true">
                          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                            <collectionProp name="Arguments.arguments">
                              <elementProp name="" elementType="HTTPArgument">
                                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                                <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                                <stringProp name="Argument.metadata">=</stringProp>
                              </elementProp>
                            </collectionProp>
                          </elementProp>
                          <stringProp name="HTTPSampler.domain">${server}</stringProp>
                          <stringProp name="HTTPSampler.port"></stringProp>
                          <stringProp name="HTTPSampler.protocol">https</stringProp>
                          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                          <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                          <stringProp name="HTTPSampler.method">POST</stringProp>
                          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                          <stringProp name="HTTPSampler.response_timeout"></stringProp>
                          <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                        </HTTPSamplerProxy>
                        <hashTree>
                          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                            <collectionProp name="HeaderManager.headers">
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">Content-Type</stringProp>
                                <stringProp name="Header.value">application/json</stringProp>
                              </elementProp>
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                                <stringProp name="Header.value">testground</stringProp>
                              </elementProp>
                            </collectionProp>
                          </HeaderManager>
                          <hashTree/>
                          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                            <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                            <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                            <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                            <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                          </JSONPostProcessor>
                          <hashTree/>
                          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - timeCheck" enabled="true">
                            <boolProp name="resetInterpreter">false</boolProp>
                            <stringProp name="parameters"></stringProp>
                            <stringProp name="filename"></stringProp>
                            <stringProp name="script">//RecordStartTime2
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
vars.put(&quot;relogin&quot;,&quot;0&quot;);</stringProp>
                          </BeanShellPostProcessor>
                          <hashTree/>
                        </hashTree>
                      </hashTree>
                      <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="API Name - ${apiName}" enabled="true">
                        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                          <collectionProp name="Arguments.arguments"/>
                        </elementProp>
                        <stringProp name="HTTPSampler.domain">${server}</stringProp>
                        <stringProp name="HTTPSampler.port">${port}</stringProp>
                        <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
                        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                        <stringProp name="HTTPSampler.path"></stringProp>
                        <stringProp name="HTTPSampler.method">POST</stringProp>
                        <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                        <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                        <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                        <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                        <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                        <stringProp name="HTTPSampler.connect_timeout">120000</stringProp>
                        <stringProp name="HTTPSampler.response_timeout"></stringProp>
                        <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                      </HTTPSamplerProxy>
                      <hashTree>
                        <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                          <collectionProp name="HeaderManager.headers"/>
                        </HeaderManager>
                        <hashTree/>
                        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Manage HTTP  Headers and api method for the REST API" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">
//Add any additional headers as required
import org.apache.jmeter.protocol.http.control.Header;
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.*;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell starts&quot;);
	sampler.setMethod(vars.get(&quot;apiMethod&quot;));	
     JSONObject urlInputFields = new JSONObject(vars.get(&quot;urlInputParameters&quot;));// vars.get(&quot;urlInputParameters&quot;)
	 log.info(&quot;URL Input fields: &quot;+urlInputFields.toString());
	Object aObj = urlInputFields.get(&quot;urlParameter&quot;);
	String urlParameterValue=null;
	String apiFullPathValue =&quot;NA&quot;;
	if(aObj instanceof Integer){
   if (debug) log.info(&quot;Integer : &quot;+String.valueOf(aObj));
     urlParameterValue=urlInputFields.getInt(&quot;urlParameter&quot;).toString();
}
else
{
	if (debug) log.info(&quot;String :&quot;+String.valueOf(aObj));
	urlParameterValue=urlInputFields.getString(&quot;urlParameter&quot;);
}
if (debug) log.info(&quot;---&quot;+urlParameterValue);
	if (urlParameterValue.length()&gt;0 &amp;&amp; !urlParameterValue.equals(null) &amp;&amp; !urlParameterValue.equals(&quot;NA&quot;))
	{
//		if (debug)log.info(&quot;--------------path with parameter&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue));
		apiFullPathValue = vars.get(&quot;apiPath&quot;).concat(&quot;/&quot;).concat(urlParameterValue);
	} else {
//		if (debug) log.info(&quot;--------------only path&quot;);
		sampler.setPath(vars.get(&quot;apiPath&quot;));		
		apiFullPathValue = vars.get(&quot;apiPath&quot;);
	}

			
	vars.put(&quot;apiFullPathValue&quot;,apiFullPathValue);
//	if (vars.get(&quot;inputPayloadExistence&quot;).equals(&quot;yes&quot;)) {
		if (vars.get(&quot;jsonPayload&quot;).length()&gt;5) {
			sampler.setPostBodyRaw(true);
			sampler.addNonEncodedArgument(&quot;&quot;,vars.get(&quot;jsonPayload&quot;),&quot;&quot;);

			//log.info(&quot;payload File is----&gt;&quot;+vars.get(&quot;jsonPayload&quot;));
		}
//	}
	String apiHeadersString = &quot;&quot;;
	if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;)) apiHeadersString=vars.get(&quot;apiHeadersGETPUT&quot;); 
	else apiHeadersString=vars.get(&quot;apiHeaders&quot;);
	log.info(&quot;API Header String: &quot;+apiHeadersString);
       
	int countOfExistingHeaders = sampler.getHeaderManager().size();
	if (debug) log.info(&quot;Count of headers: &quot;+String.valueOf(countOfExistingHeaders));
	if (countOfExistingHeaders==0) {
		JSONObject apiHeadersObject = new JSONObject(apiHeadersString);		
		Iterator newKeys = apiHeadersObject.keys();
		while (newKeys.hasNext()) {
			String newKey = newKeys.next();
			sampler.getHeaderManager().add(new Header(newKey,apiHeadersObject.getString(newKey)));
		}
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	} else {
		sampler.getHeaderManager().removeHeaderNamed(&quot;Authorization&quot;);
		if (vars.get(&quot;apiMethod&quot;).equals(&quot;PUT&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;GET&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;POST&quot;) || vars.get(&quot;apiMethod&quot;).equals(&quot;DELETE&quot;))   {
			sampler.getHeaderManager().add(new Header(&quot;Authorization&quot;,vars.get(&quot;bearerToken&quot;)));
		}
	}

	if (debug) log.info(&quot;Manage HTTP  Headers and api method for the REST API - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2300&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}
</stringProp>
                        </BeanShellPreProcessor>
                        <hashTree/>
                        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Store the payload injection date and time" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Store the payload injection date and time
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String payloadInjectionDate = dateFormatter.format(cal.getTime());
	String payloadInjectionTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;payloadInjectionDate&quot;,payloadInjectionDate);
	vars.put(&quot;payloadInjectionTime&quot;,payloadInjectionTime);
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2400&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode);
	f.close();
}</stringProp>
                        </BeanShellPreProcessor>
                        <hashTree/>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Store response JSON and validate response code /  compare JSON" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Store results JSON in the appropriate folder
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
import com.github.wnameless.json.unflattener.JsonUnflattener;
import com.github.wnameless.json.flattener.JsonFlattener;
import java.util.regex.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.*;
import java.util.Map;
import jsonComparator.*;
import ignore.*;
import selectedFieldsJson.*;
jsonComparator1 jComparator = new jsonComparator1();
ignore ignoreCommon = new ignore();
selectedFieldsJson selectedFieldsClassObject = new selectedFieldsJson();


try {
	 Object responseMsg1;
	 Object responseMsg2;
	 Object responseMsg3;
	 Object responseMsg4;
	 
	String jsonResultsFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(vars.get(&quot;apiNameExpected&quot;)).concat(&quot;.json&quot;);//	
	//log.info(&quot;jsonResultsFileName-----&gt;&quot;+jsonResultsFileName);
	
	f = new FileOutputStream(jsonResultsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(prev.getResponseDataAsString());
	f.close();

	//get_expectedResponseCode
	String reasonForFailure=&quot;&quot;;
	int expectedResponseCode =0;
	//log.info(vars.get(&quot;expectedResultsArray&quot;));
	String responseType =&quot;JSON&quot;; 
	JSONArray fetexpectedResponseCodeFromArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
	int fetexpectedResponseCodeFromArraySize=fetexpectedResponseCodeFromArray.length();
	int checkExpectedResponseCode = Integer.valueOf(vars.get(&quot;testScenarioNumber&quot;));
		for(int i=0;i&lt;fetexpectedResponseCodeFromArraySize;i++)
			{
				JSONObject newJSonObject = new JSONObject();		
				newJSonObject = fetexpectedResponseCodeFromArray.getJSONObject((checkExpectedResponseCode-1));
				expectedResponseCode=newJSonObject.getInt(&quot;expectedResponseCode&quot;);	
			}

		//JSONObject newExpectedResults after trimming the expected response code
		if (String.valueOf(expectedResponseCode).equals(prev.getResponseCode())) {
			vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
			
			//jsonComparator
		 	String responseMsg= prev.getResponseDataAsString();
		 	 try
				 {
				 	JSONObject newJsonObject2 = new JSONObject(responseMsg);
				 	responseMsg1=newJsonObject2;
	 	
					 } catch (Exception e) {try
										 {	
										 	JSONArray newJsonArray2 = new JSONArray(responseMsg);
										 	responseMsg1= newJsonArray2;
		
										 }catch (Exception e) {
//													 		log.info(&quot;String-------&gt;&quot;);
													 		responseType=&quot;String&quot;;
													 		responseMsg2= responseMsg;
													 		}					 		 	
					 					}
		 	
		 	
		 	if(vars.get(&quot;jsonType&quot;).equalsIgnoreCase(&quot;jsonObject&quot;))
		 	{
//		 		log.info(&quot;inside of if  object&quot;);
		 	 JSONObject newJsonObject = new JSONObject(vars.get(&quot;expectedResult&quot;));
		 	responseMsg2 = newJsonObject;
		 	}else if(vars.get(&quot;jsonType&quot;).equalsIgnoreCase(&quot;jsonArray&quot;))
			 	{
//			 		log.info(&quot;inside of if  array&quot;);
			 	 JSONArray newJsonArray = new JSONArray(vars.get(&quot;expectedResult&quot;));
			 	 responseMsg2 = newJsonArray;
			 	}


						responseMsg3 =responseMsg1;
						responseMsg4 =responseMsg2;
	
		 	 //log.info(String.valueOf(responseMsg2.length()));
		 	    String checkExpectedLength =vars.get(&quot;expectedResult&quot;);
				if (checkExpectedLength.length()&gt;5)
		 	 	{	

					if(responseType.equalsIgnoreCase(&quot;JSON&quot;))
					{			
						//Ignore common
						String jsonTypeIs =vars.get(&quot;jsonType&quot;);
						JSONArray JsonIgnoreCommonArray = new JSONArray(vars.get(&quot;commonIgnoreArray&quot;));

//						log.info(String.valueOf(&quot;----&gt;&quot;+JsonIgnoreCommonArray.length()));
						int commonIgnoreSize=0;
						commonIgnoreSize =JsonIgnoreCommonArray.length();
						if(commonIgnoreSize&gt;0)
						{
						
//						JsonIgnoreCommonArray.put(&quot;lastModifiedOn&quot;);
//						JsonIgnoreCommonArray.put(&quot;createdOn&quot;);
						
						responseMsg1 = ignoreCommon.commonIgnore(jsonTypeIs,responseMsg1,JsonIgnoreCommonArray);
						responseMsg2 = ignoreCommon.commonIgnore(jsonTypeIs,responseMsg2,JsonIgnoreCommonArray);
						}
						
						JSONArray newJSONArray = new JSONArray();
						newJSONArray.put(responseMsg1);
						newJSONArray.put(responseMsg2);
						
						JSONArray ignoreKeysArray = new JSONArray(vars.get(&quot;ignoreKeysArray&quot;));
						newJSONArray.put(ignoreKeysArray);

//						log.info(&quot;---JAR---Array&quot;+String.valueOf(newJSONArray));
						
					 	String jsoncompareResult =String.valueOf(jComparator.areEqual(newJSONArray));
					 	//String.valueOf(jComparator.areEqual(responseMsg1,responseMsg2));
					 	log.info(&quot;Result---&gt;&quot;+jsoncompareResult);	
						log.info(String.valueOf(newJSONArray));
					 	if(jsoncompareResult.equalsIgnoreCase(&quot;True&quot;)){
							vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
							} else
							{
							vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;);	
							}
					}else
								 	{
								 		vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 						 		 
								 	}

	//selected field validation
	String jsonFileWriteCheck = vars.get(&quot;responseCodeValidation&quot;);
	if(jsonFileWriteCheck.equalsIgnoreCase(&quot;FAIL&quot;))
	{
		String apiNameCheck = vars.get(&quot;apiName&quot;);
		String selectedFieldsJson = vars.get(&quot;selectedFieldsJsonArray&quot;);
		JSONArray selectedFieldsJsonArray = new JSONArray(selectedFieldsJson);
		int selectedFieldsJsonArraySize= selectedFieldsJsonArray.length();
//		log.info(&quot;selectedFieldsJsonArraySize---&gt;&quot;+String.valueOf(selectedFieldsJsonArraySize));
		for(int i=0;i&lt;selectedFieldsJsonArraySize;i++)
		{
			String arrayAPIName = selectedFieldsJsonArray.get(i);
			if(apiNameCheck.equalsIgnoreCase(arrayAPIName))
			{
				String jsonTypeIs =vars.get(&quot;jsonType&quot;);				
				String selectedkeys =vars.get(&quot;selectedFieldJSONkeysArray&quot;);
				JSONArray newseletedArrayKeys = new JSONArray(vars.get(&quot;selectedFieldJSONkeysArray&quot;));
				responseMsg1=selectedFieldsClassObject.checkReturn(jsonTypeIs,responseMsg3,newseletedArrayKeys);
//				log.info(&quot;responseMsg1&quot;+responseMsg1);
				responseMsg2=selectedFieldsClassObject.checkReturn(jsonTypeIs,responseMsg4,newseletedArrayKeys);
//				log.info(&quot;responseMsg2&quot;+responseMsg2);
				JSONArray ignoreKeysArray = new JSONArray();
				JSONArray newJSONArray = new JSONArray();
						newJSONArray.put(responseMsg1);
						newJSONArray.put(responseMsg2);
						newJSONArray.put(ignoreKeysArray);
						String jsoncompareResult =String.valueOf(jComparator.areEqual(newJSONArray));
//						log.info(&quot;selected fiels compar -----&gt;&quot;+jsoncompareResult);
						if(jsoncompareResult.equalsIgnoreCase(&quot;True&quot;)){
							vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
							} else
							{
							vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;);	
							}					
				break;
			}
			
		}
		

		
	}
	
								 	
							//Write mismatch json actual and expected file 
							jsonFileWriteCheck = vars.get(&quot;responseCodeValidation&quot;);							
							if(jsonFileWriteCheck.equalsIgnoreCase(&quot;FAIL&quot;))
							{
								String jsonCompareFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(&quot;apiActualExpectedFileName&quot;).concat(vars.get(&quot;apiNameExpected&quot;)).concat(&quot;.txt&quot;);
										log.info(&quot;jsonCompareFileName&quot;+jsonCompareFileName);
										
								 		f = new FileOutputStream(jsonCompareFileName,true);
										p = new PrintStream(f); 
										this.interpreter.setOut(p);
										print(&quot;\nActual Result:------&gt; &quot;+responseMsg1);
										print(&quot;\nExpected Result:----&gt; &quot;+responseMsg2);					
										f.close();
								 		 reasonForFailure=&quot;Expected result not match with actual result:  &quot;;
								 		 reasonForFailure=reasonForFailure.concat(jsonCompareFileName);	
}



								 	
			 	 		}
		 	 	
			
		} else {
			 reasonForFailure=&quot;Actual response code received is &quot;;
			 reasonForFailure=reasonForFailure.concat(String.valueOf(prev.getResponseCode()));			 
			 vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
			 //testResult=&quot;FAIL&quot;;
		}	
	
		String actualResponseCode=&quot;NA&quot;;
		actualResponseCode =prev.getResponseCode();	 	
		//Store Results in a csv file
		String resultToBeStored =vars.get(&quot;payloadInjectionDate&quot;).concat(&quot;,&quot;).concat(vars.get(&quot;payloadInjectionTime&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;moduleName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;payloadFilePath&quot;)).concat(&quot;,&quot;).concat(jsonResultsFileName).concat(&quot;,&quot;).concat(vars.get(&quot;responseCodeValidation&quot;)).concat(&quot;,&quot;).concat(String.valueOf(expectedResponseCode)).concat(&quot;,&quot;).concat(actualResponseCode).concat(&quot;,&quot;).concat(vars.get(&quot;overallInputFile&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiMethod&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiFullPathValue&quot;)).concat(&quot;,&quot;).concat(reasonForFailure).concat(&quot;,&quot;).concat(vars.get(&quot;consentPerson&quot;));
	////	if (debug)log.info(&quot;*****&quot;+resultToBeStored);
		f = new FileOutputStream(vars.get(&quot;apiResultsFileName&quot;),true);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		print(resultToBeStored);
		f.close();
		
	 
} catch (Exception e) {
	String errorCode=&quot;2500&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;JSON Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}


</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                    </hashTree>
                  </hashTree>
                </hashTree>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller_MYSQL" enabled="true">
                <stringProp name="IfController.condition">&quot;${fileType}&quot;==&quot;json&quot; &amp;&amp; &quot;${mysql}&quot;==&quot;y&quot;</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
              </IfController>
              <hashTree>
                <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                  <stringProp name="IfController.condition">&quot;${testScenarioNumber}&quot;!=&quot;&lt;EOF&gt;&quot;</stringProp>
                  <boolProp name="IfController.evaluateAll">false</boolProp>
                </IfController>
                <hashTree>
                  <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Check SQL query input  file is available?" enabled="true">
                    <boolProp name="WAITING">true</boolProp>
                    <boolProp name="SUCCESFULL">true</boolProp>
                    <stringProp name="RESPONSE_CODE">200</stringProp>
                    <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                    <stringProp name="REQUEST_DATA">${expectedJsonPath}
${payloadJsonPath}

${jsonLoop}</stringProp>
                    <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                    <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                    <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                    <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                    <stringProp name="URL"></stringProp>
                    <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                  </kg.apc.jmeter.samplers.DummySampler>
                  <hashTree>
                    <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor_FileCheck" enabled="true">
                      <boolProp name="resetInterpreter">false</boolProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">//check_Json_File
import java.util.*;
String payloadJsonPath = vars.get(&quot;payloadJsonPath&quot;);
String expectedJsonPath=vars.get(&quot;expectedJsonPath&quot;);

String payloadJsonFileName = vars.get(&quot;payloadJSON&quot;);
String expectedJsonFileName = vars.get(&quot;expectedJSON&quot;);

String payloadFilePathString=payloadJsonPath.concat(payloadJsonFileName);
String expectedFilePathString=expectedJsonPath.concat(expectedJsonFileName);


ArrayList  listValue = new ArrayList();
listValue.add(payloadFilePathString);
listValue.add(expectedFilePathString);

vars.put(&quot;payloadFilePathString&quot;,payloadFilePathString);
vars.put(&quot;expectedFilePathString&quot;,expectedFilePathString);
// log.info(String.valueOf(listValue));

for(int i=0;i&lt;listValue.size();i++)
	{
	//log.info(listValue.get(i));
		
		File f = new File(listValue.get(i));
		if(f.exists() &amp;&amp; !f.isDirectory()) { 
		   vars.put(&quot;jsonFileCheck&quot;,&quot;y&quot;);
		   
		}
			else
			{
			log.info(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			 vars.put(&quot;fileCheck&quot;,&quot;n&quot;);
			 System.out.println(f+&quot; is not available  and tests wont be run for this &quot;+apiName+&quot; API&quot;);
			}
	}
	
</stringProp>
                    </BeanShellPreProcessor>
                    <hashTree/>
                  </hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${jsonLoop}</stringProp>
                  </LoopController>
                  <hashTree>
                    <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read data from payload tracker" enabled="true">
                      <boolProp name="WAITING">true</boolProp>
                      <boolProp name="SUCCESFULL">true</boolProp>
                      <stringProp name="RESPONSE_CODE">200</stringProp>
                      <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                      <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
                      <stringProp name="RESPONSE_DATA">${__CSVRead(${payloadTrackingFile},0)}|${__CSVRead(${payloadTrackingFile},1)}|${__CSVRead(${payloadTrackingFile},2)}|${__CSVRead(${payloadTrackingFile},3)}${__CSVRead(${payloadTrackingFile},next)}</stringProp>
                      <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                      <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                      <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                      <stringProp name="URL"></stringProp>
                      <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                    </kg.apc.jmeter.samplers.DummySampler>
                    <hashTree>
                      <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                        <boolProp name="resetInterpreter">false</boolProp>
                        <stringProp name="parameters"></stringProp>
                        <stringProp name="filename"></stringProp>
                        <stringProp name="script">//testScenarioNumber,payloadFilePath,expectedResultsFilePath,urlInputFieldsFilePath
String responseMsg = prev.getResponseDataAsString();
log.info(responseMsg);
String[] responseMsgSplit = responseMsg.split(&quot;\\|&quot;);
vars.put(&quot;testScenarioNumber&quot;,responseMsgSplit[0]);
vars.put(&quot;payloadFilePath&quot;,responseMsgSplit[1]);
vars.put(&quot;expectedResultsFilePath&quot;,responseMsgSplit[2]);
vars.put(&quot;urlInputFieldsFilePath&quot;,responseMsgSplit[3]);
log.info(responseMsgSplit[0]);
log.info(responseMsgSplit[1]);
log.info(responseMsgSplit[2]);
log.info(responseMsgSplit[3]);</stringProp>
                      </BeanShellPostProcessor>
                      <hashTree/>
                    </hashTree>
                    <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                      <stringProp name="IfController.condition">&quot;${jsonFileCheck}&quot;==&quot;y&quot;</stringProp>
                      <boolProp name="IfController.evaluateAll">false</boolProp>
                    </IfController>
                    <hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Mysql Query File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${payloadFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Mysqlquery File
import org.json.JSONArray;
import org.json.JSONObject;
try
{
JSONArray newInputFieldsJsonArray = new JSONArray();
String payloadDataArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(payloadDataArray);
log.info(String.valueOf(newJsonArray.length()));
int size=newJsonArray.length();
vars.put(&quot;numberOfRowsInCSV&quot;,String.valueOf(size));
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));

for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;queryName&quot;);
//	log.info(apiName);
//	Object mysqlQuery =newJsonObject.get(&quot;mysqlQuery&quot;);

	//check - &gt; match with apiname
	if(apiName.equalsIgnoreCase(testapiName))
	{		
			jsonPayloadFileName = vars.get(&quot;timeStampedJsonPayloadPath&quot;).concat(&quot;mysqlQuery__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
			Object mysqlQuery =newJsonObject.get(&quot;mysqlQuery&quot;);
			f = new FileOutputStream(jsonPayloadFileName, false);
			p = new PrintStream(f); 
			this.interpreter.setOut(p); 
			print(mysqlQuery);
			f.close();	
			vars.put(&quot;payloadFilePath&quot;,jsonPayloadFileName);	
			vars.put(&quot;mysqlQuery&quot;,String.valueOf(mysqlQuery));
			vars.put(&quot;testapiName&quot;,testapiName);

			//If = scenario -&gt; get apimethod and apipath from json
//			if(vars.get(&quot;scenario&quot;).equalsIgnoreCase(&quot;y&quot;))
//			{
//			String apiMethod = newJsonObject.get(&quot;apiMethod&quot;);
//			String apiPath= newJsonObject.get(&quot;apiPath&quot;);
//			vars.put(&quot;apiMethod&quot;,apiMethod);
//			vars.put(&quot;apiPath&quot;,apiPath);	
//			}
			break;
	}
		
}
}catch (Exception e) {
	String errorCode=&quot;2600&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode+&quot;;&quot;+e.toString()+&quot;: ---&gt; &quot;+vars.get(&quot;apiInputsFile&quot;));
	f.close();
}

</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read Expected Table  File" enabled="true">
                        <boolProp name="WAITING">true</boolProp>
                        <boolProp name="SUCCESFULL">true</boolProp>
                        <stringProp name="RESPONSE_CODE">200</stringProp>
                        <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                        <stringProp name="REQUEST_DATA"></stringProp>
                        <stringProp name="RESPONSE_DATA">${__FileToString(${expectedFilePathString},,)}</stringProp>
                        <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                        <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                        <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                        <stringProp name="URL"></stringProp>
                        <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
                      </kg.apc.jmeter.samplers.DummySampler>
                      <hashTree>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Read Expected Table file
import org.json.JSONArray;
import org.json.JSONObject;

JSONArray newExpectedResultsArray = new JSONArray();
String expectedResultArray = prev.getResponseDataAsString(); 
JSONArray newJsonArray = new JSONArray(expectedResultArray);
log.info(String.valueOf(newJsonArray.length()));
int size=newJsonArray.length();
String testapiName=vars.get(&quot;apiName&quot;).concat(vars.get(&quot;testScenarioNumber&quot;));
for(int i =0; i&lt;size;i++)
{
	JSONObject newJsonObject = new JSONObject();
	newJsonObject = newJsonArray.getJSONObject(i);
	String apiName=newJsonObject.getString(&quot;queryName&quot;);	
	Object expectedCheck =newJsonObject.get(&quot;expectedTableValue&quot;);
	
	//Check the expected result is Array ? or Object?
	if(expectedCheck instanceof JSONObject)
		{
		 vars.put(&quot;jsonType&quot;,&quot;jsonObject&quot;);
		}else if(expectedCheck instanceof JSONArray)
			{
			 vars.put(&quot;jsonType&quot;,&quot;jsonArray&quot;);	
//			 log.info(&quot;---------expectedTableValue-mysql query-------&quot;);
			}
	
	vars.put(&quot;expectedResult&quot;,String.valueOf(expectedCheck));	
	newExpectedResultsArray.put(expectedCheck);	
	if(apiName.equalsIgnoreCase(testapiName))
	{
		vars.put(&quot;quaryNameExpected&quot;,testapiName);
		Object expectedCheck =newJsonObject.get(&quot;expectedTableValue&quot;);

		//ignoreKeys
//		Object ignoreKeys=newJsonObject.get(&quot;ignore&quot;);
//		JSONArray commonIgnoreArray =newJsonObject.get(&quot;commonIgnore&quot;);
//		vars.put(&quot;commonIgnoreArray&quot;,String.valueOf(commonIgnoreArray));
//		vars.put(&quot;ignoreKeysArray&quot;,String.valueOf(ignoreKeys));

		String expectedResultsFileName = vars.get(&quot;timeStampedJSONWorkbenchResultsValidationPath&quot;).concat(&quot;expectedTableResults__&quot;).concat(vars.get(&quot;apiName&quot;)).concat(String.valueOf(i+1)).concat(&quot;.json&quot;);
		
		f4 = new FileOutputStream(expectedResultsFileName, false);
		p4 = new PrintStream(f4); 
		this.interpreter.setOut(p4); 
		print(expectedCheck);
		f4.close();	
		vars.put(&quot;expectedTableValue&quot;,String.valueOf(expectedCheck));
		break;
	}		
}

</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                      <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler - Check elapsed time" enabled="true">
                        <stringProp name="BeanShellSampler.query">//Check Elapsed Time
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
long startTime=Long.valueOf(vars.get(&quot;startTime_&quot;+ctx.getThreadNum()));
double diff = (timeMilli-startTime)/60000;

if (diff &gt;= 18.0) {
	vars.put(&quot;relogin&quot;,&quot;1&quot;);
} else {
	vars.put(&quot;relogin&quot;,&quot;0&quot;);
}
</stringProp>
                        <stringProp name="BeanShellSampler.filename"></stringProp>
                        <stringProp name="BeanShellSampler.parameters"></stringProp>
                        <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
                      </BeanShellSampler>
                      <hashTree/>
                      <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If elapsed time" enabled="true">
                        <stringProp name="IfController.condition">&quot;${relogin}&quot;==&quot;1&quot;</stringProp>
                        <boolProp name="IfController.evaluateAll">false</boolProp>
                      </IfController>
                      <hashTree>
                        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Bearer Token " enabled="true">
                          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                            <collectionProp name="Arguments.arguments">
                              <elementProp name="" elementType="HTTPArgument">
                                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                                <stringProp name="Argument.value">{&#xd;
  &quot;grant_type&quot;: &quot;password&quot;,&#xd;
  &quot;username&quot;: &quot;operator&quot;,&#xd;
  &quot;password&quot;: &quot;SW5pdDFAbDE=&quot;,&#xd;
  &quot;refreshTokenParam&quot;: null&#xd;
}</stringProp>
                                <stringProp name="Argument.metadata">=</stringProp>
                              </elementProp>
                            </collectionProp>
                          </elementProp>
                          <stringProp name="HTTPSampler.domain">${server}</stringProp>
                          <stringProp name="HTTPSampler.port"></stringProp>
                          <stringProp name="HTTPSampler.protocol">https</stringProp>
                          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                          <stringProp name="HTTPSampler.path">/identity/v1/token</stringProp>
                          <stringProp name="HTTPSampler.method">POST</stringProp>
                          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                          <stringProp name="HTTPSampler.response_timeout"></stringProp>
                          <stringProp name="TestPlan.comments">${__P(server)}</stringProp>
                        </HTTPSamplerProxy>
                        <hashTree>
                          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                            <collectionProp name="HeaderManager.headers">
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">Content-Type</stringProp>
                                <stringProp name="Header.value">application/json</stringProp>
                              </elementProp>
                              <elementProp name="" elementType="Header">
                                <stringProp name="Header.name">X-Tenant-Identifier</stringProp>
                                <stringProp name="Header.value">testground</stringProp>
                              </elementProp>
                            </collectionProp>
                          </HeaderManager>
                          <hashTree/>
                          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                            <stringProp name="JSONPostProcessor.referenceNames">bearerToken</stringProp>
                            <stringProp name="JSONPostProcessor.jsonPathExprs">$.accessToken</stringProp>
                            <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
                            <stringProp name="JSONPostProcessor.defaultValues">notAvailable</stringProp>
                          </JSONPostProcessor>
                          <hashTree/>
                          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor - timeCheck" enabled="true">
                            <boolProp name="resetInterpreter">false</boolProp>
                            <stringProp name="parameters"></stringProp>
                            <stringProp name="filename"></stringProp>
                            <stringProp name="script">//RecordStartTime2
import java.util.Date;
Date date = new Date();
long timeMilli = date.getTime();
vars.put(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
//log.info(&quot;startTime_&quot;+ctx.getThreadNum(),String.valueOf(timeMilli));
vars.put(&quot;relogin&quot;,&quot;0&quot;);</stringProp>
                          </BeanShellPostProcessor>
                          <hashTree/>
                        </hashTree>
                      </hashTree>
                      <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="Get Table Values from My SQL" enabled="true">
                        <stringProp name="dataSource">linearExpansion</stringProp>
                        <stringProp name="query">${mysqlQuery}</stringProp>
                        <stringProp name="queryArguments"></stringProp>
                        <stringProp name="queryArgumentsTypes"></stringProp>
                        <stringProp name="queryTimeout"></stringProp>
                        <stringProp name="queryType">Select Statement</stringProp>
                        <stringProp name="resultSetHandler">Store as String</stringProp>
                        <stringProp name="resultVariable">resultSet</stringProp>
                        <stringProp name="variableNames">combinationId,objectValue</stringProp>
                        <stringProp name="resultSetMaxRows"></stringProp>
                      </JDBCSampler>
                      <hashTree>
                        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Store the payload injection date and time" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">//Store the payload injection date and time
import java.util.Date;
import java.text.SimpleDateFormat;
import org.apache.jmeter.util.JMeterUtils;
try {
	Boolean debug;
	if (vars.get(&quot;overallDebug&quot;).equals(&quot;1&quot;)) debug=true; else debug=false;
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell starts&quot;);
	SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
	SimpleDateFormat timeFormatter = new SimpleDateFormat(&quot;hhmma&quot;);
	Calendar cal = Calendar.getInstance();
	String payloadInjectionDate = dateFormatter.format(cal.getTime());
	String payloadInjectionTime = timeFormatter.format(cal.getTime());
	vars.put(&quot;payloadInjectionDate&quot;,payloadInjectionDate);
	vars.put(&quot;payloadInjectionTime&quot;,payloadInjectionTime);
	if (debug) log.info(&quot;Store the payload injection date and time - beanshell ends&quot;);
} catch (Exception e) {
	String errorCode=&quot;2700&quot;;
	f = new FileOutputStream(vars.get(&quot;errorsFileName&quot;), true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(&quot;Error code: &quot;+errorCode);
	f.close();
}</stringProp>
                        </BeanShellPreProcessor>
                        <hashTree/>
                        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Count of Results" enabled="true">
                          <boolProp name="resetInterpreter">false</boolProp>
                          <stringProp name="parameters"></stringProp>
                          <stringProp name="filename"></stringProp>
                          <stringProp name="script">;//validate table result
import org.json.JSONArray;
import org.json.JSONObject;
import java.util.*;
import jsonComparator.*;
try
{
	
jsonComparator1 jComparator = new jsonComparator1();

String jsoncompareResult =&quot;NA&quot;;
String responseCodeValidation=&quot;NA&quot;;
String jsoncompareResult=&quot;FALSE&quot;;
int expectedResponseCode =0;
String reasonForFailure = &quot;&quot;;
String responseMsg =&quot;NA&quot;;

String responsecode = prev.getResponseCode();
String jsonResultsFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(vars.get(&quot;quaryNameExpected&quot;)).concat(&quot;.json&quot;);//	

	f = new FileOutputStream(jsonResultsFileName, true);
	p = new PrintStream(f); 
	this.interpreter.setOut(p); 
	print(prev.getResponseDataAsString());
	f.close();





	String responseType =&quot;JSON&quot;; 
	JSONArray fetexpectedResponseCodeFromArray = new JSONArray(vars.get(&quot;expectedResultsArray&quot;));
	int fetexpectedResponseCodeFromArraySize=fetexpectedResponseCodeFromArray.length();
	int checkExpectedResponseCode = Integer.valueOf(vars.get(&quot;testScenarioNumber&quot;));
		for(int i=0;i&lt;fetexpectedResponseCodeFromArraySize;i++)
			{
				JSONObject newJSonObject = new JSONObject();		
				newJSonObject = fetexpectedResponseCodeFromArray.getJSONObject((checkExpectedResponseCode-1));
				expectedResponseCode=newJSonObject.getInt(&quot;expectedResponseCode&quot;);	
			}

					//JSONObject newExpectedResults after trimming the expected response code
					if (String.valueOf(expectedResponseCode).equals(prev.getResponseCode())) 
					
					{
						responseCodeValidation = &quot;PASS&quot;;
						vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
										log.info(responsecode);
										//Get actual table result
										 responseMsg = prev.getResponseDataAsString();
										responseMsg=responseMsg.replace(&quot;actualDBResult&quot;,&quot;&quot;);
										
										//Object checkResponse = responseMsg;
										if(responseCodeValidation.equalsIgnoreCase(&quot;PASS&quot;))
										{
										
											JSONArray newactualDBResult = new JSONArray(responseMsg);
											log.info(&quot;responseMsg--&gt;&quot;+String.valueOf(newactualDBResult));
											
											//Get expected table result
											String newexpectedDBResultString = vars.get(&quot;expectedTableValue&quot;);
											JSONArray newexpectedDBResult = new JSONArray(newexpectedDBResultString);
											
																 	JSONArray newJSONArray = new JSONArray();
																	newJSONArray.put(newactualDBResult);
																	newJSONArray.put(newexpectedDBResult);
																		
																	JSONArray ignoreKeysArray = new JSONArray();
																	newJSONArray.put(ignoreKeysArray);
																	log.info(&quot;Array----&gt;&quot;+String.valueOf(newJSONArray));
											
												 jsoncompareResult =String.valueOf(jComparator.areEqual(newJSONArray));
																 	//String.valueOf(jComparator.areEqual(responseMsg1,responseMsg2));
																 	log.info(&quot;Result-----&gt;&quot;+jsoncompareResult);
																 	if(jsoncompareResult.equalsIgnoreCase(&quot;True&quot;)){
																		vars.put(&quot;responseCodeValidation&quot;,&quot;PASS&quot;);
																		} else
																		{
																		vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;);
																		log.info(&quot;-----------------&gt;FALSE&quot;);
																					jsoncompareResult=&quot;FALSE&quot;;	
																					vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
																					String jsonCompareFileName = vars.get(&quot;timeStampedJsonOutputPath&quot;).concat(&quot;jsonOutput&quot;).concat(&quot;apiActualExpectedFileName&quot;).concat(vars.get(&quot;quaryNameExpected&quot;)).concat(&quot;.txt&quot;);
																					log.info(&quot;jsonCompareFileName----------------&gt;&quot;+jsonCompareFileName);
																			 		f = new FileOutputStream(jsonCompareFileName,true);
																					p = new PrintStream(f); 
																					this.interpreter.setOut(p);
																					print(&quot;Actual Table Result: ------&gt;&quot;+responseMsg);
																					print(&quot;\nExpected Table Result:-----&gt;&quot;+vars.get(&quot;expectedTableValue&quot;));
																					f.close();
																			 		 reasonForFailure=&quot;Expected table result not match with actual table result:  &quot;;
																			 		 reasonForFailure=reasonForFailure.concat(jsonCompareFileName);		
																		}
																 	
																			}
																			
															}
				
					else {
							 reasonForFailure=&quot;Actual response code received is &quot;;
							 reasonForFailure=reasonForFailure.concat(String.valueOf(prev.getResponseCode()));			 
							 vars.put(&quot;responseCodeValidation&quot;,&quot;FAIL&quot;); 
							 log.info(reasonForFailure);
							 //testResult=&quot;FAIL&quot;;
						}	


String actualResponseCode=&quot;NA&quot;;
		actualResponseCode =prev.getResponseCode();	 	


		log.info(jsonResultsFileName);
		log.info(vars.get(&quot;responseCodeValidation&quot;));
		log.info(String.valueOf(expectedResponseCode));
		log.info(actualResponseCode);
		log.info(vars.get(&quot;overallInputFile&quot;));
		
		
		//Store Results in a csv file
		String resultToBeStored =vars.get(&quot;payloadInjectionDate&quot;).concat(&quot;,&quot;).concat(vars.get(&quot;payloadInjectionTime&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;apiName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;moduleName&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;testScenarioNumber&quot;)).concat(&quot;,&quot;).concat(vars.get(&quot;payloadFilePath&quot;)).concat(&quot;,&quot;).concat(jsonResultsFileName).concat(&quot;,&quot;).concat(vars.get(&quot;responseCodeValidation&quot;)).concat(&quot;,&quot;).concat(String.valueOf(expectedResponseCode)).concat(&quot;,&quot;).concat(actualResponseCode).concat(&quot;,&quot;).concat(vars.get(&quot;overallInputFile&quot;)).concat(&quot;,&quot;).concat(&quot;Select Query&quot;).concat(&quot;,&quot;).concat(&quot;mysqlQuery&quot;).concat(&quot;,&quot;).concat(reasonForFailure).concat(&quot;,&quot;).concat(vars.get(&quot;consentPerson&quot;));



		
	////	if (debug)log.info(&quot;*****&quot;+resultToBeStored);
		f = new FileOutputStream(vars.get(&quot;apiResultsFileName&quot;),true);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		print(resultToBeStored);
		f.close();




}
catch(Exception e){log.info(e);}
</stringProp>
                        </BeanShellPostProcessor>
                        <hashTree/>
                      </hashTree>
                    </hashTree>
                  </hashTree>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
      </hashTree>
      <PostThreadGroup guiclass="PostThreadGroupGui" testclass="PostThreadGroup" testname="tearDown Thread Group" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </PostThreadGroup>
      <hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="Create Overall Results Dashboard for the Test Run" enabled="true">
          <stringProp name="BeanShellSampler.query">//Create Overall Results Dashboard for the Test Run
import org.apache.jmeter.util.JMeterUtils;
File folder = new File(JMeterUtils.getProperty(&quot;timeStampledResultsPath&quot;));//vars.get(&quot;folder&quot;));
File[] files = folder.listFiles();
int counter = 1;
String overallResultsFile = JMeterUtils.getProperty(&quot;overallResultsFileName&quot;);
f = new FileOutputStream(overallResultsFile, true);
p = new PrintStream(f); 
this.interpreter.setOut(p);
int count=1;
int overallPassCount=0;
int overallFailCount=0;
String Owner =&quot;&quot;;
for (int i=0;i&lt;files.length;i++) {
	if (!files[i].toString().equals(overallResultsFile.toString())) {
		BufferedReader br = new BufferedReader(new FileReader(files[i]));     
		String line;
		String apiName=&quot;&quot;;
		String moduleName=&quot;&quot;;
		String payloadInjectionDate=&quot;&quot;;
		String payloadInjectionTime=&quot;&quot;;
		int passCount=0;
		int failCount=0;
		
		Boolean checkResult=false;
		while ((line=br.readLine())!=null) {
			String[] splitLine = line.split(&quot;,&quot;);
			if (!splitLine[0].equals(&quot;Test Execution Date&quot;)) {
				apiName=splitLine[2];
				moduleName=splitLine[3];
				payloadInjectionDate=splitLine[0];
				payloadInjectionTime=splitLine[1];
				
				//log.info(splitLine[7]);
				
				if (splitLine[7].equals(&quot;PASS&quot;))
				{
					passCount++;
					checkResult=true;
					Owner =splitLine[14];
				}
				if (splitLine[7].equals(&quot;FAIL&quot;))
				{
					failCount++;
					checkResult=true;
					Owner =splitLine[14];
				}
				
			}

		}
		if(checkResult)
		{
		print(String.valueOf(count).concat(&quot;,&quot;).concat(payloadInjectionDate).concat(&quot;,&quot;).concat(payloadInjectionTime).concat(&quot;,&quot;).concat(apiName).concat(&quot;,&quot;).concat(moduleName).concat(&quot;,&quot;).concat(String.valueOf(passCount+failCount)).concat(&quot;,&quot;).concat(String.valueOf(passCount)).concat(&quot;,&quot;).concat(String.valueOf(failCount)).concat(&quot;,&quot;).concat(String.valueOf(Owner)));
		overallPassCount=overallPassCount+passCount;
		overallFailCount=overallFailCount+failCount;
		count++;
		}
	}
}
print(&quot;,,,,Total,&quot;.concat(String.valueOf(overallPassCount+overallFailCount)).concat(&quot;,&quot;).concat(String.valueOf(overallPassCount)).concat(&quot;,&quot;).concat(String.valueOf(overallFailCount)));
f.close();</stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
      </hashTree>
      <PostThreadGroup guiclass="PostThreadGroupGui" testclass="PostThreadGroup" testname="Failure API Test Result" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </PostThreadGroup>
      <hashTree>
        <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read File From the Folder" enabled="true">
          <boolProp name="WAITING">true</boolProp>
          <boolProp name="SUCCESFULL">true</boolProp>
          <stringProp name="RESPONSE_CODE">200</stringProp>
          <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
          <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
          <stringProp name="RESPONSE_DATA">${fileArray}</stringProp>
          <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
          <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
          <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
          <stringProp name="URL"></stringProp>
          <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
        </kg.apc.jmeter.samplers.DummySampler>
        <hashTree>
          <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">//Read file from folder
import org.apache.jmeter.util.JMeterUtils;
import org.json.*;
String filePath = JMeterUtils.getProperty(&quot;timeStampledResultsPath&quot;);
vars.put(&quot;filePath&quot;,filePath);
//String filePath=vars.get(&quot;filePath&quot;);
File folder = new File(filePath);
File[] listOfFiles = folder.listFiles();
String exceptFile = &quot;overall_results.csv&quot;;
String html =&quot;FailureAPIResults.html&quot;;
String fileNAme=null;

JSONArray newJsonArray = new JSONArray();


for (File file : listOfFiles) {
    if (file.isFile()) {
    	fileNAme=file.getName();
    	if(!exceptFile.equalsIgnoreCase(fileNAme))
    	{
    	if(!exceptFile.equalsIgnoreCase(html))
    	{
    		JSONObject  newJsonObject = new JSONObject();
    		newJsonObject.put(&quot;file&quot;,fileNAme);
    		 newJsonArray.put(newJsonObject);   		
//        log.info(file.getName());
    	}
    	}
    }
}
//log.info(String.valueOf(newJsonArray));
vars.put(&quot;fileArray&quot;,String.valueOf(newJsonArray));</stringProp>
          </BeanShellPreProcessor>
          <hashTree/>
          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
            <stringProp name="JSONPostProcessor.referenceNames">fileName</stringProp>
            <stringProp name="JSONPostProcessor.jsonPathExprs">$..file</stringProp>
            <stringProp name="JSONPostProcessor.match_numbers">-1</stringProp>
            <stringProp name="Scope.variable"></stringProp>
            <stringProp name="JSONPostProcessor.defaultValues">NA</stringProp>
            <stringProp name="Sample.scope">all</stringProp>
          </JSONPostProcessor>
          <hashTree/>
        </hashTree>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
          <stringProp name="ForeachController.inputVal">fileName</stringProp>
          <stringProp name="ForeachController.returnVal">insidefileName</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
        </ForeachController>
        <hashTree>
          <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read File Name -- ${insidefileName}" enabled="true">
            <boolProp name="WAITING">true</boolProp>
            <boolProp name="SUCCESFULL">true</boolProp>
            <stringProp name="RESPONSE_CODE">200</stringProp>
            <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
            <stringProp name="REQUEST_DATA">${testExecutionDate}
${payloadInjectionTime}
${APIName}
${moduleName}
${testScenarioNumber}
${JSONPayload}
${resultsJSONFileName}
${testResult}
${reasonForFailure}</stringProp>
            <stringProp name="RESPONSE_DATA">${filePath}</stringProp>
            <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
            <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
            <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
            <stringProp name="URL"></stringProp>
            <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
          </kg.apc.jmeter.samplers.DummySampler>
          <hashTree>
            <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">String filePath = vars.get(&quot;filePath&quot;);
String fileName= vars.get(&quot;insidefileName&quot;);
String payloadTrackingFile =filePath.concat(fileName);
vars.put(&quot;payloadTrackingFile&quot;,payloadTrackingFile);

//Clean
vars.put(&quot;testExecutionDate&quot;,&quot;NA&quot;);
vars.put(&quot;payloadInjectionTime&quot;,&quot;NA&quot;);
vars.put(&quot;APIName&quot;,&quot;NA&quot;);
vars.put(&quot;moduleName&quot;,&quot;NA&quot;);
vars.put(&quot;testScenarioNumber&quot;,&quot;NA&quot;);
vars.put(&quot;JSONPayload&quot;,&quot;NA&quot;);
vars.put(&quot;resultsJSONFileName&quot;,&quot;NA&quot;);
vars.put(&quot;testResult&quot;,&quot;NA&quot;);
vars.put(&quot;reasonForFailure&quot;,&quot;NA&quot;);
</stringProp>
            </BeanShellPreProcessor>
            <hashTree/>
          </hashTree>
          <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Find the number of scenarios" enabled="true">
            <boolProp name="WAITING">true</boolProp>
            <boolProp name="SUCCESFULL">true</boolProp>
            <stringProp name="RESPONSE_CODE">200</stringProp>
            <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
            <stringProp name="REQUEST_DATA">${payloadTrackingFile}</stringProp>
            <stringProp name="RESPONSE_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
            <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
            <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
            <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
            <stringProp name="URL"></stringProp>
            <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
          </kg.apc.jmeter.samplers.DummySampler>
          <hashTree>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">//payloadTrackingFile--1
String fileName = vars.get(&quot;payloadTrackingFile&quot;);
log.info(&quot;Filename: &quot;+fileName);
int numberOfRowsInCSV=0;
//log.info(fileName)
BufferedReader brTest = new BufferedReader(new FileReader(fileName));

		while ((line = brTest.readLine()) != null)
		{
			numberOfRowsInCSV++;
		}
		brTest.close();

vars.put(&quot;numberOfRowsInCSV&quot;,String.valueOf(numberOfRowsInCSV));</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
          </hashTree>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">${numberOfRowsInCSV}</stringProp>
          </LoopController>
          <hashTree>
            <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Read data from payload tracker" enabled="true">
              <boolProp name="WAITING">true</boolProp>
              <boolProp name="SUCCESFULL">true</boolProp>
              <stringProp name="RESPONSE_CODE">200</stringProp>
              <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
              <stringProp name="REQUEST_DATA">Dummy Sampler used to simulate requests and responses
without actual network activity. This helps debugging tests.</stringProp>
              <stringProp name="RESPONSE_DATA">${__CSVRead(${payloadTrackingFile},0)}TCMAPI${__CSVRead(${payloadTrackingFile},1)}TCMAPI${__CSVRead(${payloadTrackingFile},2)}TCMAPI${__CSVRead(${payloadTrackingFile},3)}TCMAPI${__CSVRead(${payloadTrackingFile},4)}TCMAPI${__CSVRead(${payloadTrackingFile},5)}TCMAPI${__CSVRead(${payloadTrackingFile},6)}TCMAPI${__CSVRead(${payloadTrackingFile},7)}TCMAPI${__CSVRead(${payloadTrackingFile},8)}TCMAPI${__CSVRead(${payloadTrackingFile},9)}TCMAPI${__CSVRead(${payloadTrackingFile},10)}TCMAPI${__CSVRead(${payloadTrackingFile},11)}TCMAPI${__CSVRead(${payloadTrackingFile},12)}TCMAPI${__CSVRead(${payloadTrackingFile},13)}${__CSVRead(${payloadTrackingFile},next)}</stringProp>
              <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
              <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
              <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
              <stringProp name="URL"></stringProp>
              <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
            </kg.apc.jmeter.samplers.DummySampler>
            <hashTree>
              <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                <boolProp name="resetInterpreter">false</boolProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">//testScenarioNumber,payloadFilePath,expectedResultsFilePath,urlInputFieldsFilePath
try
{
String responseMsg = prev.getResponseDataAsString();
//log.info(responseMsg);
String[] responseMsgSplit = responseMsg.split(&quot;TCMAPI&quot;);
vars.put(&quot;testExecutionDate&quot;,responseMsgSplit[0]);
vars.put(&quot;payloadInjectionTime&quot;,responseMsgSplit[1]);
vars.put(&quot;APIName&quot;,responseMsgSplit[2]);
vars.put(&quot;moduleName&quot;,responseMsgSplit[3]);
vars.put(&quot;testScenarioNumber&quot;,responseMsgSplit[4]);
vars.put(&quot;JSONPayload&quot;,responseMsgSplit[5]);
vars.put(&quot;resultsJSONFileName&quot;,responseMsgSplit[6]);
vars.put(&quot;testResult&quot;,responseMsgSplit[7]);
vars.put(&quot;expectedResponseCode&quot;,responseMsgSplit[8]);
vars.put(&quot;actualResponseCode&quot;,responseMsgSplit[9]);
vars.put(&quot;apiInputsFile&quot;,responseMsgSplit[10]);
vars.put(&quot;apiMethod&quot;,responseMsgSplit[11]);
vars.put(&quot;apiPathValue&quot;,responseMsgSplit[12]);
vars.put(&quot;reasonForFailure&quot;,responseMsgSplit[13]);

}
catch (Exception e) {log.info(&quot;Error&quot;);}


</stringProp>
              </BeanShellPostProcessor>
              <hashTree/>
            </hashTree>
            <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller-Check -testResult" enabled="true">
              <stringProp name="IfController.condition">&quot;${testResult}&quot;==&quot;FAIL&quot; || &quot;${testResult}&quot;==&quot;Fail&quot;</stringProp>
              <boolProp name="IfController.evaluateAll">false</boolProp>
            </IfController>
            <hashTree>
              <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="Counter" enabled="true">
                <stringProp name="CounterConfig.start">1</stringProp>
                <stringProp name="CounterConfig.end"></stringProp>
                <stringProp name="CounterConfig.incr">1</stringProp>
                <stringProp name="CounterConfig.name">counter_Value</stringProp>
                <stringProp name="CounterConfig.format"></stringProp>
                <boolProp name="CounterConfig.per_user">false</boolProp>
              </CounterConfig>
              <hashTree/>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Payload_JSONFile" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">${JSONPayload}</stringProp>
                <stringProp name="RESPONSE_DATA">${__FileToString(${JSONPayload},,)}</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">String responseJSONPayload = prev.getResponseDataAsString();
vars.put(&quot;responseJSONPayload&quot;,responseJSONPayload);</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Results_JSONFile" enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">${resultsJSONFileName}</stringProp>
                <stringProp name="RESPONSE_DATA">${__FileToString(${resultsJSONFileName},,)}</stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">String responseresultsJSON = prev.getResponseDataAsString();
vars.put(&quot;responseresultsJSON&quot;,responseresultsJSON);</stringProp>
                </BeanShellPostProcessor>
                <hashTree/>
              </hashTree>
              <kg.apc.jmeter.samplers.DummySampler guiclass="kg.apc.jmeter.samplers.DummySamplerGui" testclass="kg.apc.jmeter.samplers.DummySampler" testname="Write Date Into HTML  " enabled="true">
                <boolProp name="WAITING">true</boolProp>
                <boolProp name="SUCCESFULL">true</boolProp>
                <stringProp name="RESPONSE_CODE">200</stringProp>
                <stringProp name="RESPONSE_MESSAGE">OK</stringProp>
                <stringProp name="REQUEST_DATA">Test Result -- ${testResult}
${counter_Value}</stringProp>
                <stringProp name="RESPONSE_DATA"></stringProp>
                <stringProp name="RESPONSE_TIME">${__Random(50,500)}</stringProp>
                <stringProp name="LATENCY">${__Random(1,50)}</stringProp>
                <stringProp name="CONNECT">${__Random(1,5)}</stringProp>
                <stringProp name="URL"></stringProp>
                <stringProp name="RESULT_CLASS">org.apache.jmeter.samplers.SampleResult</stringProp>
              </kg.apc.jmeter.samplers.DummySampler>
              <hashTree>
                <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor_V2" enabled="true">
                  <boolProp name="resetInterpreter">false</boolProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">//Write report detail in HTML

String payloadInjectionDate =vars.get(&quot;testExecutionDate&quot;);
String time =vars.get(&quot;payloadInjectionTime&quot;);
String APIName =vars.get(&quot;APIName&quot;);
String moduleName= vars.get(&quot;moduleName&quot;);
String testScenarioNumber = vars.get(&quot;testScenarioNumber&quot;);
String JSONPayload= vars.get(&quot;responseJSONPayload&quot;);
String resultsJSONFileName =vars.get(&quot;responseresultsJSON&quot;);
String testResult =vars.get(&quot;testResult&quot;);
String reasonForFailure =&quot;NA&quot;;
reasonForFailure=vars.get(&quot;reasonForFailure&quot;);
String checkResult=vars.get(&quot;testResult&quot;);
String counter =vars.get(&quot;counter_Value&quot;);
String expectedResponseCode =vars.get(&quot;expectedResponseCode&quot;);
String actualResponseCode =vars.get(&quot;actualResponseCode&quot;);
String apiInputsFile =vars.get(&quot;apiInputsFile&quot;);
String apiMethod =vars.get(&quot;apiMethod&quot;);
String apiPathValue =vars.get(&quot;apiPathValue&quot;);
log.info(&quot;counter :&quot;+counter);


//log.info(&quot;APIName-----&gt;&quot;+APIName);
//log.info(&quot;moduleName-----&gt;&quot;+moduleName);
//log.info(&quot;testResult-----&gt;&quot;+testResult);
//log.info(&quot;reasonForFailure-----&gt;&quot;+reasonForFailure);
//log.info(&quot;APIName-----&gt;&quot;+APIName);
//log.info(&quot;APIName-----&gt;&quot;+APIName);

String outPutFile=&quot;&quot;;
 if(JSONPayload.equalsIgnoreCase(&quot;**ERR**&quot;))
 {
 JSONPayload=&quot;NA&quot;;	
 }
  if(resultsJSONFileName.equalsIgnoreCase(&quot;**ERR**&quot;))
 {
 resultsJSONFileName=&quot;NA&quot;;	
 }


if(checkResult.equalsIgnoreCase(&quot;FAIL&quot;))
{
//Create HTML File
String apiResultsFileName = vars.get(&quot;filePath&quot;).concat(&quot;FailureAPIResults.html&quot;);
f = new FileOutputStream(apiResultsFileName,true);
String colorCode=&quot;#99ff99&quot;;
p = new PrintStream(f);
//Write File Content
		if(counter.equalsIgnoreCase(&quot;1&quot;)){	
		
			p.print(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;New Page&lt;/title&gt;&lt;/head&gt;&lt;style&gt;table {border-collapse: collapse;border-spacing: 0;table-layout: fixed;width: 100%;border: 1px solid #ddd;}th, td {text-align: center;padding: 8px;border: 1px solid black;}&lt;/style&gt;&lt;body&gt;&lt;p bgcolor=&quot;+colorCode+&quot;&gt;Failure API Test Result - &quot;+payloadInjectionDate+&quot;-&quot;+time+&quot;&lt;/p&gt;&lt;table&gt;&lt;tr&gt;&lt;th bgcolor=&quot;+colorCode+&quot;&gt;API Name _ Test Scenario Number / API Input File&lt;/th&gt;&lt;th bgcolor=&quot;+colorCode+&quot;&gt;Method Type / API Path / Query Type&lt;/th&gt;&lt;th bgcolor=&quot;+colorCode+&quot;&gt;Expected Response Code / PayLoad / Mysql Query&lt;/th&gt;&lt;th bgcolor=&quot;+colorCode+&quot;&gt;Actual Response Code / Response Data&lt;/th&gt;&lt;th bgcolor=&quot;+colorCode+&quot;&gt;Reason For Failure&lt;/th&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
		}

if(apiMethod.equalsIgnoreCase(&quot;Select Query&quot;)){
	//Insert the data for SQL
p.println(&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;style&gt;table {border-collapse: collapse;border-spacing: 0;table-layout: fixed;width: 100%;border: 1px solid #ddd;text-align: center;}th, td {text-align: center;word-wrap: break-word;padding: 8px;border: 1px solid black;}&lt;/style&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td wrap&gt;&quot;+APIName+&quot; _ &quot;+testScenarioNumber+&quot;&lt;details&gt;&lt;summary&gt;SQL Input File&lt;/summary&gt;&lt;p&gt;&quot;+apiInputsFile+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;td&gt;&quot;+apiMethod+&quot;&lt;br&gt;&quot;+&quot;&lt;/td&gt;&lt;td wrap&gt;Expected : &quot;+expectedResponseCode+&quot;&lt;details&gt;&lt;summary&gt;Query Body&lt;/summary&gt;&lt;p&gt;&quot;+JSONPayload+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;td wrap&gt;Actual : &quot;+actualResponseCode+&quot;&lt;details&gt;&lt;summary&gt;Response Table Data&lt;/summary&gt;&lt;p&gt;&quot;+resultsJSONFileName+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;td wrap&gt;&lt;details&gt;&lt;summary&gt;Reason&lt;/summary&gt;&lt;p&gt;&quot;+reasonForFailure+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);	
	
}
		else
		{
//Insert the data for API
p.println(&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;style&gt;table {border-collapse: collapse;border-spacing: 0;table-layout: fixed;width: 100%;border: 1px solid #ddd;text-align: center;}th, td {text-align: center;word-wrap: break-word;padding: 8px;border: 1px solid black;}&lt;/style&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td wrap&gt;&quot;+APIName+&quot; _ &quot;+testScenarioNumber+&quot;&lt;details&gt;&lt;summary&gt;API Input File&lt;/summary&gt;&lt;p&gt;&quot;+apiInputsFile+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;td&gt;&quot;+apiMethod+&quot;&lt;br&gt;&quot;+apiPathValue+&quot;&lt;/td&gt;&lt;td wrap&gt;Expected : &quot;+expectedResponseCode+&quot;&lt;details&gt;&lt;summary&gt;Request Body&lt;/summary&gt;&lt;p&gt;&quot;+JSONPayload+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;td wrap&gt;Actual : &quot;+actualResponseCode+&quot;&lt;details&gt;&lt;summary&gt;Response Body&lt;/summary&gt;&lt;p&gt;&quot;+resultsJSONFileName+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;td wrap&gt;&lt;details&gt;&lt;summary&gt;Reason&lt;/summary&gt;&lt;p&gt;&quot;+reasonForFailure+&quot;&lt;/p&gt;&lt;/details&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);	
		}	

p.close();
f.close();	
}



</stringProp>
                </BeanShellPreProcessor>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
